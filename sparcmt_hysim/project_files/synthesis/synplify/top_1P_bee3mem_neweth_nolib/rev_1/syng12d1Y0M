--
-- Copyright (c) 1994 - 2003 Synplicity Inc
-- $Header: //synplicity/maprc/mappers/xilinx/lib/gen_virtex5/ram_r_w.vhd#1 $
--

----- CELL XRAM32X1D -----
library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_signed.all;
library unisim;
use unisim.vcomponents.all;

entity XRAM32X1D is
  port (
        DPO   : out std_ulogic;        
        SPO   : out std_ulogic;

        A0    : in std_ulogic;
        A1    : in std_ulogic;
        A2    : in std_ulogic;
        A3    : in std_ulogic;
        A4    : in std_ulogic;
        D     : in std_ulogic;
        DPRA0 : in std_ulogic;
        DPRA1 : in std_ulogic;
        DPRA2 : in std_ulogic;
        DPRA3 : in std_ulogic;
        DPRA4 : in std_ulogic;
        WCLK  : in std_ulogic;        
        WE    : in std_ulogic
       );  
end XRAM32X1D;
architecture XRAM32X1D_V of XRAM32X1D is
  	signal we0, we1, so0, so1, do0, do1: std_logic;
begin
	DPO <= do0 when (DPRA4 = '0') else do1;
	SPO <= so0 when (A4 = '0') else so1;
	we0 <= WE and (not A4);
	we1 <= WE and A4;
 	U0 : RAM16X1D 
                port map (D => D, A0 => A0, A1 => A1, A2 => A2, A3 => A3,
 			DPRA0 => DPRA0, DPRA1 => DPRA1, DPRA2 => DPRA2, DPRA3 => DPRA3, 
			WE => we0, WCLK => WCLK, DPO => do0, SPO => so0);
 	U1 : RAM16X1D 
                port map (D => D, A0 => A0, A1 => A1, A2 => A2, A3 => A3,
 			DPRA0 => DPRA0, DPRA1 => DPRA1, DPRA2 => DPRA2, DPRA3 => DPRA3, 
			WE => we1, WCLK => WCLK, DPO => do1, SPO => so1);
end XRAM32X1D_V;

----- CELL XRAM64X1D -----
library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_signed.all;
library unisim;
use unisim.vcomponents.all;

entity XRAM64X1D is
  port (
        DPO   : out std_ulogic;        
        SPO   : out std_ulogic;

        A0    : in std_ulogic;
        A1    : in std_ulogic;
        A2    : in std_ulogic;
        A3    : in std_ulogic;
        A4    : in std_ulogic;
        A5    : in std_ulogic;
        D     : in std_ulogic;
        DPRA0 : in std_ulogic;
        DPRA1 : in std_ulogic;
        DPRA2 : in std_ulogic;
        DPRA3 : in std_ulogic;
        DPRA4 : in std_ulogic;
        DPRA5 : in std_ulogic;
        WCLK  : in std_ulogic;        
        WE    : in std_ulogic
       );  
end XRAM64X1D;
architecture XRAM64X1D_V of XRAM64X1D is
  	signal we0, we1, we2, we3, so0, so1, so2, so3, do0, do1, do2, do3: std_logic;
begin
	DPO <=  do0 when (DPRA5 = '0' and DPRA4 = '0') else 
		do1 when (DPRA5 = '0' and DPRA4 = '1') else 
		do2 when (DPRA5 = '1' and DPRA4 = '0') else 
		do3;
	SPO <=  so0 when (A5 = '0' and A4 = '0') else 
		so1 when (A5 = '0' and A4 = '1') else 
		so2 when (A5 = '1' and A4 = '0') else 
		so3;
	we0 <= WE and (not A5) and (not A4);
	we1 <= WE and (not A5) and A4;
	we2 <= WE and A5 and (not A4);
	we3 <= WE and A5 and A4;
 	U0 : RAM16X1D 
                port map (D => D, A0 => A0, A1 => A1, A2 => A2, A3 => A3,
 			DPRA0 => DPRA0, DPRA1 => DPRA1, DPRA2 => DPRA2, DPRA3 => DPRA3, 
			WE => we0, WCLK => WCLK, DPO => do0, SPO => so0);
 	U1 : RAM16X1D 
                port map (D => D, A0 => A0, A1 => A1, A2 => A2, A3 => A3,
 			DPRA0 => DPRA0, DPRA1 => DPRA1, DPRA2 => DPRA2, DPRA3 => DPRA3, 
			WE => we1, WCLK => WCLK, DPO => do1, SPO => so1);
 	U2 : RAM16X1D 
                port map (D => D, A0 => A0, A1 => A1, A2 => A2, A3 => A3,
 			DPRA0 => DPRA0, DPRA1 => DPRA1, DPRA2 => DPRA2, DPRA3 => DPRA3, 
			WE => we2, WCLK => WCLK, DPO => do2, SPO => so2);
 	U3 : RAM16X1D 
                port map (D => D, A0 => A0, A1 => A1, A2 => A2, A3 => A3,
 			DPRA0 => DPRA0, DPRA1 => DPRA1, DPRA2 => DPRA2, DPRA3 => DPRA3, 
			WE => we3, WCLK => WCLK, DPO => do3, SPO => so3);
end XRAM64X1D_V;

--
--
-- Simple RAM with single ADDRESS for both read and write
-- Target : Xilinx
--

library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_signed.all;
library unisim;
use unisim.vcomponents.all;
entity RAM_R_W is
	generic (
	    family : string := "none";
		width : integer := 1; 
		addrwidth : integer := 6;        -- big enough for depth
		depth : integer := 48;
		dout_reg : boolean := false;      -- has output reg
		din_reg : boolean := false;        -- has data input reg
		raddr_reg : boolean := false;      -- has read address reg
		waddr_reg : boolean  := false      -- has write address reg
		);
	port (
		DOUT: out std_logic_vector(width-1 downto 0);
		RADDR : in std_logic_vector(addrwidth-1 downto 0);
		DIN  : in std_logic_vector(width-1 downto 0);
		WADDR : in std_logic_vector(addrwidth-1 downto 0);
		WE  : in std_logic;       -- write enable for ram
		CLK : in std_logic;       -- clock for ram, addr, din
		OCLK : in std_logic       -- opt clock for w_dout
		);
end entity RAM_R_W;

--
-- First implementation must be called arch0
--
architecture block_ram of RAM_R_W is
component XRAM32X1D   port (
        DPO   : out std_ulogic;        
        SPO   : out std_ulogic;

        A0    : in std_ulogic;
        A1    : in std_ulogic;
        A2    : in std_ulogic;
        A3    : in std_ulogic;
        A4    : in std_ulogic;
        D     : in std_ulogic;
        DPRA0 : in std_ulogic;
        DPRA1 : in std_ulogic;
        DPRA2 : in std_ulogic;
        DPRA3 : in std_ulogic;
        DPRA4 : in std_ulogic;
        WCLK  : in std_ulogic;        
        WE    : in std_ulogic
       );  
end component;
component XRAM64X1D   port (
        DPO   : out std_ulogic;        
        SPO   : out std_ulogic;

        A0    : in std_ulogic;
        A1    : in std_ulogic;
        A2    : in std_ulogic;
        A3    : in std_ulogic;
        A4    : in std_ulogic;
        A5    : in std_ulogic;
        D     : in std_ulogic;
        DPRA0 : in std_ulogic;
        DPRA1 : in std_ulogic;
        DPRA2 : in std_ulogic;
        DPRA3 : in std_ulogic;
        DPRA4 : in std_ulogic;
        DPRA5 : in std_ulogic;
        WCLK  : in std_ulogic;        
        WE    : in std_ulogic
       );  
end component;
function func_init(b : boolean) return string is
begin
  if (b) then
    return("");
  else
    return("Could not implement Block RAM. Is the read address registered using the same clock as the RAM?");
  end if;
end func_init;
function get_end_depth(size : integer ; depth : integer) return integer is
variable min_size : integer := 0;
begin
  min_size := depth;
  if (size < depth) then
    min_size := size;
  end if;
  return min_size;
end get_end_depth;
attribute generator_report : string;
attribute generator_report of block_ram : architecture is func_init(raddr_reg);
-- begin block ram implementation signals
type int_array is array (0 to 5) of integer;
constant width_array : int_array := (1, 2, 4, 9, 18, 36);
constant depth_array : int_array := (16384, 8192, 4096, 2048, 1024, 512);
constant div32 : integer := (width-1)/36;
constant div16 : integer := (width-1)/18;
constant div8 : integer := (width-1)/9;
constant div4 : integer := (width-1)/4;
constant div2 : integer := (width-1)/2;
constant div1 : integer := (width-1)/1;

constant bool1 : boolean := (div1 > 0);
constant bool2 : boolean := (div2 > 0);
constant bool4 : boolean := (div4 > 0);
constant bool8 : boolean := (div8 > 0);
constant bool16 : boolean := (div16 > 0);
constant bool32 : boolean := (div32 > 0);

constant div16384 : integer := (depth-1)/16384;
constant div8192 : integer := (depth-1)/8192;
constant div4096 : integer := (depth-1)/4096;
constant div2048 : integer := (depth-1)/2048;
constant div1024 : integer := (depth-1)/1024;
constant div512 : integer := (depth-1)/512;

constant bool512 : boolean := (div512 > 0);
constant bool1024 : boolean := (div1024 > 0);
constant bool2048 : boolean := (div2048 > 0);
constant bool4096 : boolean := (div4096 > 0);
constant bool8192 : boolean := (div8192 > 0);
constant bool16384 : boolean := (div16384 > 0);

constant sum_width : integer := BOOLEAN'pos(bool1) + BOOLEAN'pos(bool2) + BOOLEAN'pos(bool4) + BOOLEAN'pos(bool8) + BOOLEAN'pos(bool16);
constant sum_depth : integer := 5 - (BOOLEAN'pos(bool512) + BOOLEAN'pos(bool1024) + BOOLEAN'pos(bool2048) + BOOLEAN'pos(bool4096) + BOOLEAN'pos(bool8192));

constant w_choice_width : integer := width_array(sum_width);
constant w_choice_depth : integer := depth_array(sum_width);
constant d_choice_width : integer := width_array(sum_depth);
constant d_choice_depth : integer := depth_array(sum_depth);

constant w_width_num_cells : integer := (width-1)/w_choice_width + 1;
constant w_depth_num_cells : integer := (depth-1)/w_choice_depth + 1;

constant d_width_num_cells : integer := (width-1)/d_choice_width + 1;
constant d_depth_num_cells : integer := (depth-1)/d_choice_depth + 1;

constant w_size : integer := w_width_num_cells * w_depth_num_cells;
constant d_size : integer := d_width_num_cells * d_depth_num_cells;

constant bool_d : boolean := (d_size - w_size <= 0);
constant bool_w : boolean := not(bool_d);

constant choice_width : integer := (BOOLEAN'pos(bool_d) * d_choice_width) + (BOOLEAN'pos(bool_w) * w_choice_width);
constant choice_depth : integer := (BOOLEAN'pos(bool_d) * d_choice_depth) + (BOOLEAN'pos(bool_w) * w_choice_depth);
constant width_num_cells : integer := (BOOLEAN'pos(bool_d) *(width-1)/d_choice_width) + (BOOLEAN'pos(bool_w) * (width-1)/w_choice_width) + 1;
constant depth_num_cells : integer := (BOOLEAN'pos(bool_d) *(depth-1)/d_choice_depth) + (BOOLEAN'pos(bool_w) * (depth-1)/w_choice_depth) + 1;
type out_bus1_type is array (depth_num_cells-1 downto 0, width_num_cells-1 downto 0) of std_logic;
signal out_bus1 : out_bus1_type;                                                        -- 2D array of r_dout (input to tri-states)
type out_bus2_type is array (depth_num_cells-1 downto 0, 2*width_num_cells+1 downto 0) of std_logic;
signal out_bus2 : out_bus2_type;                                                        -- 2D array of r_dout (input to tri-states)
type out_bus4_type is array (depth_num_cells-1 downto 0, 4*width_num_cells+3 downto 0) of std_logic;
signal out_bus4 : out_bus4_type;                                                        -- 2D array of r_dout (input to tri-states)
type out_bus8_type is array (depth_num_cells-1 downto 0, 8*width_num_cells+7 downto 0) of std_logic;
signal out_bus8 : out_bus8_type;                                                        -- 2D array of r_dout (input to tri-states)
type parity_bus8_type is array (depth_num_cells-1 downto 0, width_num_cells-1 downto 0) of std_logic;
signal parity_bus8 : parity_bus8_type;                                                  -- 2D array of r_dout (input to tri-states)
type out_bus16_type is array (depth_num_cells-1 downto 0, 16*width_num_cells+15 downto 0) of std_logic;
signal out_bus16 : out_bus16_type;                                                      -- 2D array of r_dout (input to tri-states)
type parity_bus16_type is array (depth_num_cells-1 downto 0, 2*width_num_cells+1 downto 0) of std_logic;
signal parity_bus16 : parity_bus16_type;                                                -- 2D array of r_dout (input to tri-states)
type out_bus32_type is array (depth_num_cells-1 downto 0, 32*width_num_cells+31 downto 0) of std_logic;
signal out_bus32 : out_bus32_type;                                                      -- 2D array of r_dout (input to tri-states)
type parity_bus32_type is array (depth_num_cells-1 downto 0, 4*width_num_cells+3 downto 0) of std_logic;
signal parity_bus32 : parity_bus32_type;                                                -- 2D array of r_dout (input to tri-states)
signal out_en : std_logic_vector(depth_num_cells-1 downto 0);                                 -- enables for tri-states
signal wrt_en : std_logic_vector(depth_num_cells-1 downto 0);                                 -- write enables for each row of RAM cells
signal in_reg : std_logic_vector(width+35 downto 0);                                   -- used to register DIN 
signal out_reg : std_logic_vector(width+35 downto 0);                                  -- used to register DOUT
signal out_reg1 : std_logic_vector(width-1 downto 0);                                 -- used to choose between DIN and output of Block RAM
signal rad_reg : std_logic_vector(addrwidth-1 downto 0);                               -- used to register RADDR
signal wad_reg : std_logic_vector(addrwidth-1 downto 0);                               -- used to register WADDR
signal low_raddr : std_logic_vector(13 downto 0);                                       -- raddr bits input to RAM cells (4 bits required)
signal low_waddr : std_logic_vector(13 downto 0);                                       -- waddr bits input to RAM cells (4 bits required)
signal RADDR_tmp : std_logic_vector(addrwidth-1 downto 0);                               -- used to pipeline RADDR
signal WADDR_tmp : std_logic_vector(addrwidth-1 downto 0);                               -- used to pipeline WADDR
signal DIN_tmp : std_logic_vector(width-1 downto 0);                                     -- used to pipeline DIN
signal WE_tmp : std_logic;                                                               -- used to pipeline WE
-- end block ram implementation signals
-- begin select ram implementation signals
function get_num_64(depth: integer) return integer is
variable val : integer := 0;
begin
  val := depth/64;
  if ((depth mod 64) > 48) then
    val := val + 1;
  end if;
  return val;
end get_num_64;
function get_leftover_32(depth : integer) return integer is
begin
  return(depth mod 64);
end get_leftover_32;
function get_leftover(depth : integer; max : integer) return integer is
variable val : integer := 0;
begin
  if (depth - max >= 0) then
    val := depth - max;
  else
    val := depth;
  end if;
  return(val);
end get_leftover;
function get_num_32(depth : integer) return integer is
variable val : integer := 0;
begin
  if (depth <= 48 and depth > 16) then
     val := 1;
  end if;
  return val;
end get_num_32;
function get_num_16(depth : integer) return integer is
variable val : integer := 0;
begin
  if (depth <= 16 and depth > 0) then
     val := 1;
  end if;
  return val;
end get_num_16;
constant num_cell_64 : integer := get_num_64(depth);
constant leftover_32 : integer := get_leftover_32(depth);
constant num_cell_32 : integer := get_num_32(leftover_32);
constant leftover_16 : integer := get_leftover(leftover_32, 32);
constant num_cell_16 : integer := get_num_16(leftover_16);

type out_bus_type_64s is array (num_cell_64 downto 0, width-1 downto 0) of std_logic;
type out_bus_type_32s is array (num_cell_32 downto 0, width-1 downto 0) of std_logic;
type out_bus_type_16s is array (num_cell_16 downto 0, width-1 downto 0) of std_logic;
signal out_bus_64s : out_bus_type_64s;                                                        -- 2D array of dout (input to tri-states)
signal out_bus_32s : out_bus_type_32s;                                                        -- 2D array of dout (input to tri-states)
signal out_bus_16s : out_bus_type_16s;                                                        -- 2D array of dout (input to tri-states)
signal out_en_s : std_logic_vector(num_cell_64 downto 0);                                 -- enables for tri-states
signal out_en_32 : std_logic;
signal out_en_16 : std_logic;
signal wrt_en_s : std_logic_vector(num_cell_64 downto 0);                                 -- write enables for each row of RAM cells
signal wrt_en_32 : std_logic;
signal wrt_en_16 : std_logic;
signal in_reg_s : std_logic_vector(width-1 downto 0);                                   -- used to register DIN 
signal out_reg_s : std_logic_vector(width-1 downto 0);                                  -- used to register DOUT
signal rad_reg_s : std_logic_vector(addrwidth-1 downto 0);                               -- used to register ADDR
signal wad_reg_s : std_logic_vector(addrwidth-1 downto 0);                               -- used to register ADDR
signal low_raddr_s : std_logic_vector(5 downto 0);                                       -- addr bits input to RAM cells (4 bits required)
signal low_waddr_s : std_logic_vector(5 downto 0);                                       -- addr bits input to RAM cells (4 bits required)
-- end select ram implementation signals
attribute \.ram_offset\ : string;

begin
  U43: if (raddr_reg) generate -- generate block ram
    -- If addrwidth < choice_width assign '0' to unused bits
    U0  : if (addrwidth = 1) generate
	    low_raddr <= "0000000000000" & rad_reg(0);
	    low_waddr <= "0000000000000" & wad_reg(0);
	end generate U0;
    U1  : if (addrwidth = 2) generate
		low_raddr <= "000000000000" & rad_reg(1 downto 0);
	    low_waddr <= "000000000000" & wad_reg(1 downto 0);
	end generate U1;
    U2  : if (addrwidth = 3) generate
		low_raddr <= "00000000000" & rad_reg(2 downto 0);
	    low_waddr <= "00000000000" & wad_reg(2 downto 0);
	end generate U2;
    U3  : if (addrwidth = 4) generate
		low_raddr <= "0000000000" & rad_reg(3 downto 0);
	    low_waddr <= "0000000000" & wad_reg(3 downto 0);
	end generate U3;
    U4  : if (addrwidth = 5) generate
	    low_raddr <= "000000000" & rad_reg(4 downto 0);
	    low_waddr <= "000000000" & wad_reg(4 downto 0);
	end generate U4;
    U5  : if (addrwidth = 6) generate
	    low_raddr <= "00000000" & rad_reg(5 downto 0);
		low_waddr <= "00000000" & wad_reg(5 downto 0);
	end generate U5;
    U6  : if (addrwidth = 7) generate
	    low_raddr <= "0000000" & rad_reg(6 downto 0);
		low_waddr <= "0000000" & wad_reg(6 downto 0);
	end generate U6;
    U7  : if (addrwidth = 8) generate
	    low_raddr <= "000000" & rad_reg(7 downto 0);
		low_waddr <= "000000" & wad_reg(7 downto 0);
	end generate U7;
    U8  : if (addrwidth = 9) generate
	    low_raddr <= "00000" & rad_reg(8 downto 0);
		low_waddr <= "00000" & wad_reg(8 downto 0);
	end generate U8;
    U9  : if (addrwidth = 10) generate
	    low_raddr <= "0000" & rad_reg(9 downto 0);
		low_waddr <= "0000" & wad_reg(9 downto 0);
	end generate U9;
    U10  : if (addrwidth = 11) generate
	    low_raddr <= "000" & rad_reg(10 downto 0);
		low_waddr <= "000" & wad_reg(10 downto 0);
	end generate U10;
    U11  : if (addrwidth = 12) generate
	    low_raddr <= "00" & rad_reg(11 downto 0);
		low_waddr <= "00" & wad_reg(11 downto 0);
	end generate U11;
    U12  : if (addrwidth = 13) generate
	    low_raddr <= '0' & rad_reg(12 downto 0);
		low_waddr <= '0' & wad_reg(12 downto 0);
	end generate U12;
    U13  : if (addrwidth > 13) generate
	    low_raddr <= rad_reg(13 downto 0);
	    low_waddr <= wad_reg(13 downto 0);
	end generate U13;

    -- If (din_reg) register DIN using CLK
    U14  : if (din_reg) generate
        process (CLK, DIN) begin
            if (CLK = '1' and CLK'event) then
                in_reg <= ("000000000000000000000000000000000000" & DIN);
            end if;
        end process;
	end generate U14;
    U15  : if (not din_reg) generate
            in_reg <= ("000000000000000000000000000000000000" & DIN);
	end generate U15;

    -- If (rdout_reg) register R_DOUT using R_OCLK
    U16  : if (dout_reg) generate
        process (OCLK, out_reg1) begin
            if (OCLK = '1' and OCLK'event) then
                DOUT <= out_reg1;
            end if;
        end process;
        end generate U16;
    U17  : if (not dout_reg) generate
            DOUT <= out_reg1;
	end generate U17;

    -- If (raddr_reg) register RADDR using OCLK
    U16r  : if (raddr_reg) generate
--        process (OCLK, RADDR) begin
--            if (OCLK = '1' and OCLK'event) then
--                rad_reg <= RADDR(addrwidth-1 downto 0);
--            end if;
--        end process;
--	end generate U16r;
--    U17r : if (not raddr_reg) generate
            rad_reg <= RADDR;
	end generate U16r;

	-- If (waddr_reg) register WADDR using W_OCLK
    U16w  : if (waddr_reg) generate
        process (CLK, WADDR) begin
            if (CLK = '1' and CLK'event) then
                wad_reg <= WADDR(addrwidth-1 downto 0);
            end if;
        end process;
	end generate U16w;
    U17w : if (not waddr_reg) generate
            wad_reg <= WADDR;
	end generate U17w;

    -- Extra logic for Dual port case
	Ureg : process(CLK) begin
	  if (CLK'EVENT and CLK = '1') then
	   DIN_tmp <= DIN;
	   RADDR_tmp <= RADDR;
	   WADDR_tmp <= WADDR;
	   WE_tmp <= WE;
	  end if;
	end process;

	-- If Read Address = Write Address, bypass DIN to output if WE is enabled
	Umux : process(WE_tmp, RADDR_tmp, WADDR_tmp, DIN_tmp, out_reg)
	  begin
	    if (WADDR_tmp = RADDR_tmp and WE_tmp = '1') then
		  out_reg1 <= DIN_tmp;
		else
		  out_reg1 <= out_reg(width-1 downto 0);
		end if;
	end process;
	    
    -- Generate the RAM cells and select logic for RAMB16_S1_S1
	U18 : if (choice_width = 1) generate
    	U19 : for i in (depth_num_cells - 1) downto 0 generate
	-- If (addrwidth > 14) need to create write enable and output enable select logic
        	U20 : if (addrwidth > 14) generate
	-- fix for call 13887, select of tristate not being registered
				out_en(i) <= '1' when (RADDR_tmp(addrwidth-1 downto 14) = i) else '0';
                wrt_en(i) <= WE when (wad_reg(addrwidth-1 downto 14) = i) else '0';
        	end generate U20;
	-- If (addrwidth <= 14) no write enable or output enable select logic needed
 	    	U21 : if (addrwidth <= 14) generate
				out_en(i) <= '1';
                wrt_en(i) <= WE;
        	end generate U21;
	-- Generate the RAM cells and tri-states
        	U22 : for j in (width_num_cells - 1) downto 0 generate
                attribute \.ram_offset\ of BRAM_16384X1D : label is "W";
                begin
            	BRAM_16384X1D : RAMB16_S1_S1
	            port map (DIA(0) => in_reg(j), ADDRA => low_waddr(13 downto 0), DIB => "0", ADDRB => low_raddr(13 downto 0),
				ENA => '1', SSRA => '0', WEA => wrt_en(i), CLKA => CLK, ENB => '1', SSRB => '0', WEB => '0', CLKB => CLK,
			    DOA => open, DOB(0) => out_bus1(i,j));

                out_reg(j) <= out_bus1(i,j) when (out_en(i) = '1') else 'Z';
        	end generate U22;
     	end generate U19;
    end generate U18;    
      
    -- Generate the RAM cells and select logic for RAMB16_S2_S2
	U23 : if (choice_width = 2) generate
    	U24 : for i in (depth_num_cells - 1) downto 0 generate
	-- If (addrwidth > 13) need to create write enable and output enable select logic
        	U25 : if (addrwidth > 13) generate
	-- fix for call 13887, select of tristate not being registered
                out_en(i) <= '1' when (RADDR_tmp(addrwidth-1 downto 13) = i) else '0';
                wrt_en(i) <= WE when (wad_reg(addrwidth-1 downto 13) = i) else '0';
        	end generate U25;
	-- If (addrwidth <= 13) no write enable or output enable select logic needed
 	    	U26 : if (addrwidth <= 13) generate
	            out_en(i) <= '1';
                wrt_en(i) <= WE;
        	end generate U26;
	-- Generate the RAM cells and tri-states
        	U27 : for j in (width_num_cells - 1) downto 0 generate
                attribute \.ram_offset\ of BRAM_8192X2D : label is "W";
                begin
            	BRAM_8192X2D : RAMB16_S2_S2
	            port map (DIA => in_reg(2*j+1 downto 2*j), ADDRA => low_waddr(12 downto 0), DIB => "00", ADDRB => low_raddr(12 downto 0),
			    ENA => '1', SSRA => '0', WEA => wrt_en(i), CLKA => CLK, ENB => '1', SSRB => '0', WEB => '0', CLKB => CLK,
			    DOA => open, DOB(1) => out_bus2(i,2*j+1), DOB(0) => out_bus2(i, 2*j));
                out_reg(2*j) <= out_bus2(i,2*j) when (out_en(i) = '1') else 'Z';
                out_reg(2*j+1) <= out_bus2(i,2*j+1) when (out_en(i) = '1') else 'Z';
        	end generate U27;
     	end generate U24;
    end generate U23;  

	    -- Generate the RAM cells and select logic for RAMB16_S4_S4
	U28 : if (choice_width = 4) generate
    	U29 : for i in (depth_num_cells - 1) downto 0 generate
	-- If (addrwidth > 12) need to create write enable and output enable select logic
        	U30 : if (addrwidth > 12) generate
	-- fix for call 13887, select of tristate not being registered
                out_en(i) <= '1' when (RADDR_tmp(addrwidth-1 downto 12) = i) else '0';
                wrt_en(i) <= WE when (wad_reg(addrwidth-1 downto 12) = i) else '0';
        	end generate U30;
	-- If (addrwidth <= 12) no write enable or output enable select logic needed
 	    	U31 : if (addrwidth <= 12) generate
				out_en(i) <= '1';
                wrt_en(i) <= WE;
        	end generate U31;
	-- Generate the RAM cells and tri-states
        	U32 : for j in (width_num_cells - 1) downto 0 generate
                attribute \.ram_offset\ of BRAM_4096X4D : label is "W";
                begin
            	BRAM_4096X4D : RAMB16_S4_S4
	            port map (DIA => in_reg(4*j+3 downto 4*j), ADDRA => low_waddr(11 downto 0), DIB => "0000", ADDRB => low_raddr(11 downto 0),
				ENA => '1', SSRA => '0', WEA => wrt_en(i), CLKA => CLK, ENB => '1', SSRB => '0', WEB => '0', CLKB => CLK,
				DOA => open, DOB(3) => out_bus4(i, 4*j+3), DOB(2) => out_bus4(i,4*j+2), 
				DOB(1) => out_bus4(i,4*j+1), DOB(0) => out_bus4(i, 4*j));
                out_reg(4*j) <= out_bus4(i,4*j) when (out_en(i) = '1') else 'Z';
                out_reg(4*j+1) <= out_bus4(i,4*j+1) when (out_en(i) = '1') else 'Z';
                out_reg(4*j+2) <= out_bus4(i,4*j+2) when (out_en(i) = '1') else 'Z';
                out_reg(4*j+3) <= out_bus4(i,4*j+3) when (out_en(i) = '1') else 'Z';

        	end generate U32;
     	end generate U29;
    end generate U28;

	    -- Generate the RAM cells and select logic for RAMB16_S9_S9
	U33 : if (choice_width = 9) generate
    	U34 : for i in (depth_num_cells - 1) downto 0 generate
	-- If (addrwidth > 11) need to create write enable and output enable select logic
        	U35 : if (addrwidth > 11) generate
	-- fix for call 13887, select of tristate not being registered
                out_en(i) <= '1' when (RADDR_tmp(addrwidth-1 downto 11) = i) else '0';
                wrt_en(i) <= WE when (wad_reg(addrwidth-1 downto 11) = i) else '0';
        	end generate U35;
	-- If (addrwidth <= 11) no write enable or output enable select logic needed
 	    	U36 : if (addrwidth <= 11) generate
	            out_en(i) <= '1';
                wrt_en(i) <= WE;
        	end generate U36;
	-- Generate the RAM cells and tri-states
        	U37 : for j in (width_num_cells - 1) downto 0 generate
                attribute \.ram_offset\ of BRAM_2048X8D : label is "W";
                begin
            	BRAM_2048X8D : RAMB16_S9_S9
                  port map (DIA => in_reg(9*j+7 downto 9*j), ADDRA => low_waddr(10 downto 0), DIB => "00000000", ADDRB => low_raddr(10 downto 0),
                            ENA => '1', SSRA => '0', WEA => wrt_en(i), CLKA => CLK, ENB => '1', SSRB => '0', WEB => '0', CLKB => CLK, 
                            DOA => open, DOB(7) => out_bus8(i,8*j+7), DOB(6) => out_bus8(i,8*j+6), 
                            DOB(5) => out_bus8(i,8*j+5), DOB(4) => out_bus8(i,8*j+4), DOB(3) => out_bus8(i,8*j+3), 
                            DOB(2) => out_bus8(i,8*j+2), DOB(1) => out_bus8(i,8*j+1), DOB(0) => out_bus8(i,8*j), 
                            DIPA(0) => in_reg(9*j+8), DIPB => "0", DOPA => open, DOPB(0) => parity_bus8(i,j));
                out_reg(9*j) <= out_bus8(i,8*j) when (out_en(i) = '1') else 'Z';
                out_reg(9*j+1) <= out_bus8(i,8*j+1) when (out_en(i) = '1') else 'Z';
                out_reg(9*j+2) <= out_bus8(i,8*j+2) when (out_en(i) = '1') else 'Z';
                out_reg(9*j+3) <= out_bus8(i,8*j+3) when (out_en(i) = '1') else 'Z';
                out_reg(9*j+4) <= out_bus8(i,8*j+4) when (out_en(i) = '1') else 'Z';
                out_reg(9*j+5) <= out_bus8(i,8*j+5) when (out_en(i) = '1') else 'Z';
                out_reg(9*j+6) <= out_bus8(i,8*j+6) when (out_en(i) = '1') else 'Z';
                out_reg(9*j+7) <= out_bus8(i,8*j+7) when (out_en(i) = '1') else 'Z';
                out_reg(9*j+8) <= parity_bus8(i,j) when (out_en(i) = '1') else 'Z';
        	end generate U37;
     	end generate U34;
    end generate U33;

	    -- Generate the RAM cells and select logic for RAMB16_S18_S18
	U38 : if (choice_width = 18) generate
    	U39 : for i in (depth_num_cells - 1) downto 0 generate
	-- If (addrwidth > 10) need to create write enable and output enable select logic
        	U40 : if (addrwidth > 10) generate
	-- fix for call 13887, select of tristate not being registered
                out_en(i) <= '1' when (RADDR_tmp(addrwidth-1 downto 10) = i) else '0';
                wrt_en(i) <= WE when (wad_reg(addrwidth-1 downto 10) = i) else '0';
        	end generate U40;
	-- If (addrwidth <= 10) no write enable or output enable select logic needed
 	    	U41 : if (addrwidth <= 10) generate
	            out_en(i) <= '1';
                wrt_en(i) <= WE;
        	end generate U41;
	-- Generate the RAM cells and tri-states
        	U42 : for j in (width_num_cells - 1) downto 0 generate
                attribute \.ram_offset\ of BRAM_1024X16D : label is "W";
                begin
            	BRAM_1024X16D : RAMB16_S18_S18
                  port map (DIA => in_reg(18*j+15 downto 18*j), ADDRA => low_waddr(9 downto 0), DIB => "0000000000000000", ADDRB => low_raddr(9 downto 0),
                            ENA => '1', SSRA => '0', WEA => wrt_en(i), CLKA => CLK, ENB => '1', SSRB => '0', WEB => '0', CLKB => CLK, 
                            DOA => open, DOB(15) => out_bus16(i,16*j+15), DOB(14) => out_bus16(i,16*j+14), 
                            DOB(13) => out_bus16(i,16*j+13), DOB(12) => out_bus16(i,16*j+12), DOB(11) => out_bus16(i,16*j+11), 
                            DOB(10) => out_bus16(i,16*j+10), DOB(9) => out_bus16(i,16*j+9), DOB(8) => out_bus16(i,16*j+8), 
                            DOB(7) => out_bus16(i,16*j+7), DOB(6) => out_bus16(i,16*j+6), DOB(5) => out_bus16(i,16*j+5), 
                            DOB(4) => out_bus16(i,16*j+4), DOB(3) => out_bus16(i,16*j+3), DOB(2) => out_bus16(i,16*j+2), 
                            DOB(1) => out_bus16(i,16*j+1), DOB(0) => out_bus16(i,16*j), 
                            DIPA => in_reg(18*j+17 downto 18*j+16), DIPB => "00", DOPA => open,
                            DOPB(1) => parity_bus16(i,2*j+1), DOPB(0) => parity_bus16(i,2*j));
                out_reg(18*j) <= out_bus16(i,16*j) when (out_en(i) = '1') else 'Z';
                out_reg(18*j+1) <= out_bus16(i,16*j+1) when (out_en(i) = '1') else 'Z';
                out_reg(18*j+2) <= out_bus16(i,16*j+2) when (out_en(i) = '1') else 'Z';
                out_reg(18*j+3) <= out_bus16(i,16*j+3) when (out_en(i) = '1') else 'Z';
                out_reg(18*j+4) <= out_bus16(i,16*j+4) when (out_en(i) = '1') else 'Z';
                out_reg(18*j+5) <= out_bus16(i,16*j+5) when (out_en(i) = '1') else 'Z';
                out_reg(18*j+6) <= out_bus16(i,16*j+6) when (out_en(i) = '1') else 'Z';
                out_reg(18*j+7) <= out_bus16(i,16*j+7) when (out_en(i) = '1') else 'Z';
                out_reg(18*j+8) <= out_bus16(i,16*j+8) when (out_en(i) = '1') else 'Z';
                out_reg(18*j+9) <= out_bus16(i,16*j+9) when (out_en(i) = '1') else 'Z';
                out_reg(18*j+10) <= out_bus16(i,16*j+10) when (out_en(i) = '1') else 'Z';
                out_reg(18*j+11) <= out_bus16(i,16*j+11) when (out_en(i) = '1') else 'Z';
                out_reg(18*j+12) <= out_bus16(i,16*j+12) when (out_en(i) = '1') else 'Z';
                out_reg(18*j+13) <= out_bus16(i,16*j+13) when (out_en(i) = '1') else 'Z';
                out_reg(18*j+14) <= out_bus16(i,16*j+14) when (out_en(i) = '1') else 'Z';
                out_reg(18*j+15) <= out_bus16(i,16*j+15) when (out_en(i) = '1') else 'Z';
                out_reg(18*j+16) <= parity_bus16(i,2*j) when (out_en(i) = '1') else 'Z';
                out_reg(18*j+17) <= parity_bus16(i,2*j+1) when (out_en(i) = '1') else 'Z';
        	end generate U42;
     	end generate U39;
    end generate U38;

	    -- Generate the RAM cells and select logic for RAMB16_S36_S36
	U38a : if (choice_width = 36) generate
	    U39a : for i in (depth_num_cells - 1) downto 0 generate
	-- If (addrwidth > 9) need to create write enable and output enable select logic
			U40a : if (addrwidth > 9) generate
	-- fix for call 13887, select of tristate not being registered
				out_en(i) <= '1' when (RADDR_tmp(addrwidth-1 downto 9) = i) else '0';
				wrt_en(i) <= WE when (wad_reg(addrwidth-1 downto 9) = i) else '0';
			end generate U40a;
	-- If (addrwidth <= 9) no write enable or output enable select logic needed
			U41a : if (addrwidth <= 9) generate
				out_en(i) <= '1';
				wrt_en(i) <= WE;
			end generate U41a;
	-- Generate the RAM cells and tri-states
			U42a : for j in (width_num_cells - 1) downto 0 generate
                attribute \.ram_offset\ of BRAM_512X32D : label is "W";
                begin
				BRAM_512X32D : RAMB16_S36_S36
                                  port map (DIA => in_reg(36*j+31 downto 36*j), ADDRA => low_waddr(8 downto 0), DIB => "00000000000000000000000000000000", ADDRB => low_raddr(8 downto 0),
                                            ENA => '1', SSRA => '0', WEA => wrt_en(i), CLKA => CLK, ENB => '1', SSRB => '0', WEB => '0', CLKB => CLK,
                                            DOA => open, DOB(31) => out_bus32(i,32*j+31), DOB(30) => out_bus32(i,32*j+30),
                                            DOB(29) => out_bus32(i,32*j+29), DOB(28) => out_bus32(i,32*j+28), DOB(27) => out_bus32(i,32*j+27),
                                            DOB(26) => out_bus32(i,32*j+26), DOB(25) => out_bus32(i,32*j+25), DOB(24) => out_bus32(i,32*j+24),
                                            DOB(23) => out_bus32(i,32*j+23), DOB(22) => out_bus32(i,32*j+22), DOB(21) => out_bus32(i,32*j+21),
                                            DOB(20) => out_bus32(i,32*j+20), DOB(19) => out_bus32(i,32*j+19), DOB(18) => out_bus32(i,32*j+18),
                                            DOB(17) => out_bus32(i,32*j+17), DOB(16) => out_bus32(i,32*j+16), DOB(15) => out_bus32(i,32*j+15),
                                            DOB(14) => out_bus32(i,32*j+14), DOB(13) => out_bus32(i,32*j+13), DOB(12) => out_bus32(i,32*j+12),
                                            DOB(11) => out_bus32(i,32*j+11), DOB(10) => out_bus32(i,32*j+10), DOB(9) => out_bus32(i,32*j+9),
                                            DOB(8) => out_bus32(i,32*j+8), DOB(7) => out_bus32(i,32*j+7), DOB(6) => out_bus32(i,32*j+6),
                                            DOB(5) => out_bus32(i,32*j+5), DOB(4) => out_bus32(i,32*j+4), DOB(3) => out_bus32(i,32*j+3),
                                            DOB(2) => out_bus32(i,32*j+2), DOB(1) => out_bus32(i,32*j+1), DOB(0) => out_bus32(i,32*j),
                                            DIPA => in_reg(36*j+35 downto 36*j+32), DIPB => "0000", DOPA => open,
                                            DOPB(3) => parity_bus32(i,4*j+3), DOPB(2) => parity_bus32(i,4*j+2),
                                            DOPB(1) => parity_bus32(i,4*j+1), DOPB(0) => parity_bus32(i,4*j));
				out_reg(36*j) <= out_bus32(i,32*j) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+1) <= out_bus32(i,32*j+1) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+2) <= out_bus32(i,32*j+2) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+3) <= out_bus32(i,32*j+3) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+4) <= out_bus32(i,32*j+4) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+5) <= out_bus32(i,32*j+5) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+6) <= out_bus32(i,32*j+6) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+7) <= out_bus32(i,32*j+7) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+8) <= out_bus32(i,32*j+8) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+9) <= out_bus32(i,32*j+9) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+10) <= out_bus32(i,32*j+10) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+11) <= out_bus32(i,32*j+11) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+12) <= out_bus32(i,32*j+12) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+13) <= out_bus32(i,32*j+13) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+14) <= out_bus32(i,32*j+14) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+15) <= out_bus32(i,32*j+15) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+16) <= out_bus32(i,32*j+16) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+17) <= out_bus32(i,32*j+17) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+18) <= out_bus32(i,32*j+18) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+19) <= out_bus32(i,32*j+19) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+20) <= out_bus32(i,32*j+20) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+21) <= out_bus32(i,32*j+21) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+22) <= out_bus32(i,32*j+22) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+23) <= out_bus32(i,32*j+23) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+24) <= out_bus32(i,32*j+24) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+25) <= out_bus32(i,32*j+25) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+26) <= out_bus32(i,32*j+26) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+27) <= out_bus32(i,32*j+27) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+28) <= out_bus32(i,32*j+28) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+29) <= out_bus32(i,32*j+29) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+30) <= out_bus32(i,32*j+30) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+31) <= out_bus32(i,32*j+31) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+32) <= parity_bus32(i,4*j) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+33) <= parity_bus32(i,4*j+1) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+34) <= parity_bus32(i,4*j+2) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+35) <= parity_bus32(i,4*j+3) when (out_en(i) = '1') else 'Z';
			end generate U42a;
		end generate U39a;
	end generate U38a;
  end generate U43;

  U44 : if (not raddr_reg) generate -- generate select ram
    -- If addrwidth < 5 assign '0' to unused bits
    U0  : if (addrwidth = 1) generate
        low_raddr_s <= "00000" & rad_reg_s(0);
        low_waddr_s <= "00000" & wad_reg_s(0);
    end generate U0;
    U1  : if (addrwidth = 2) generate
        low_raddr_s <= "0000" & rad_reg_s(1 downto 0);
        low_waddr_s <= "0000" & wad_reg_s(1 downto 0);
    end generate U1;
    U2  : if (addrwidth = 3) generate
        low_raddr_s <= "000" & rad_reg_s(2 downto 0);
        low_waddr_s <= "000" & wad_reg_s(2 downto 0);
    end generate U2;
    U3  : if (addrwidth = 4) generate
        low_raddr_s <= "00" & rad_reg_s(3 downto 0);
        low_waddr_s <= "00" & wad_reg_s(3 downto 0);
    end generate U3;
	U4	: if (addrwidth = 5) generate
		low_raddr_s <= '0' & rad_reg_s(4 downto 0);
		low_waddr_s <= '0' & wad_reg_s(4 downto 0);
	end generate U4;
    U5  : if (addrwidth > 5) generate
        low_raddr_s <= rad_reg_s(5 downto 0);
        low_waddr_s <= wad_reg_s(5 downto 0);
    end generate U5;

    -- If (din_reg) register DIN using CLK
    U6  : if (din_reg) generate
        process (CLK, DIN) begin
            if (CLK = '1' and CLK'event) then
                in_reg_s <= DIN;
            end if;
        end process;
    end generate U6;
    U7  : if (not din_reg) generate
            in_reg_s <= DIN;
    end generate U7;

    -- If (dout_reg) register DOUT using OCLK
    U8  : if (dout_reg) generate
        process (OCLK, out_reg_s) begin
            if (OCLK = '1' and OCLK'event) then
                DOUT <= out_reg_s;
            end if;
        end process;
    end generate U8;
    U9  : if (not dout_reg) generate
            DOUT <= out_reg_s;
    end generate U9;

    -- If (addr_reg) register ADDR using CLK
    U10  : if (raddr_reg) generate
        process (CLK, RADDR) begin
            if (CLK = '1' and CLK'event) then
                rad_reg_s <= RADDR(addrwidth-1 downto 0);
            end if;
        end process;
    end generate U10;
    U11 : if (not raddr_reg) generate
            rad_reg_s <= RADDR;
    end generate U11;

    -- If (addr_reg) register ADDR using CLK
    U12  : if (waddr_reg) generate
        process (CLK, WADDR) begin
            if (CLK = '1' and CLK'event) then
                wad_reg_s <= WADDR(addrwidth-1 downto 0);
            end if;
        end process;
    end generate U12;
    U13 : if (not waddr_reg) generate
            wad_reg_s <= WADDR;
    end generate U13;
        
    -- Generate the RAM cells and select logic
    U14 : for i in (num_cell_64 - 1) downto 0 generate
    -- If (addrwidth > 5) need to create write enable and output enable select logic
        U15 : if (addrwidth > 6) generate
                out_en_s(i) <= '1' when (rad_reg_s(addrwidth-1 downto 6) = i) else '0';
                wrt_en_s(i) <= WE when (wad_reg_s(addrwidth-1 downto 6) = i) else '0';
        end generate U15;
    -- If (addrwidth <= 5) no write enable or output enable select logic needed
        U16 : if (addrwidth <= 6) generate
                out_en_s(i) <= '1';
                wrt_en_s(i) <= WE;
        end generate U16;
    -- Generate the RAM cells and tri-states
        U17 : for j in (width - 1) downto 0 generate
            attribute \.ram_offset\ of URAM64 : label is "SDT" & integer'image(width) & "D" & integer'image(i*64) & "W" & integer'image(j) & "E" & integer'image(get_end_depth((i+1)*64, depth)) & "X" & integer'image(j+1);
            begin
            URAM64 : XRAM64X1D 
                port map (D => in_reg_s(j), A0 => low_waddr_s(0), A1 => low_waddr_s(1), A2 => low_waddr_s(2),
                          A3 => low_waddr_s(3), A4 => low_waddr_s(4), A5 => low_waddr_s(5), 
						  DPRA0 => low_raddr_s(0), DPRA1 => low_raddr_s(1), DPRA2 => low_raddr_s(2),
						  DPRA3 => low_raddr_s(3), DPRA4 => low_raddr_s(4), DPRA5 => low_raddr_s(5), 
						  WE => wrt_en_s(i), WCLK => CLK, DPO => out_bus_64s(i,j));
                out_reg_s(j) <= out_bus_64s(i,j) when (out_en_s(i) = '1') else 'Z';
        end generate U17;
     end generate U14;            
      
    -- Generate a 32 word deep RAM cell if appropriate               
    U18 : if (num_cell_32 = 1) generate
    -- If (addrwidth > 7) need to create write enable and output enable select logic
        U19a : if (addrwidth > 6) generate
                out_en_32 <= '1' when ((rad_reg_s(addrwidth-1 downto 6) = num_cell_64) and (rad_reg_s(5) = '0')) else '0';
                wrt_en_32 <= WE when ((wad_reg_s(addrwidth-1 downto 6) = num_cell_64) and (wad_reg_s(5) = '0')) else '0';
        end generate U19a;
        U19b : if (addrwidth = 6 and num_cell_64 = 0) generate
                out_en_32 <= '1' when ((rad_reg_s(5) = '0')) else '0';
                wrt_en_32 <= WE when ((wad_reg_s(5) = '0')) else '0';
        end generate U19b;    -- If (addrwidth <= 5) no write enable or output enable select logic needed
        U20 : if (addrwidth <= 5) generate
                out_en_32 <= '1';
                wrt_en_32 <= WE;
        end generate U20;
    -- Generate the RAM cell and tri-state
        U21 : for j in (width - 1) downto 0 generate
            attribute \.ram_offset\ of URAM32 : label is "SDT" & integer'image(width) & "D" & integer'image(num_cell_64*64) & "W" & integer'image(j) & "E" & integer'image(get_end_depth(num_cell_64*64 + 32, depth)) & "X" & integer'image(j+1);
            begin
            URAM32 : XRAM32X1D 
                port map (D => in_reg_s(j), A0 => low_waddr_s(0), A1 => low_waddr_s(1), A2 => low_waddr_s(2),
                          A3 => low_waddr_s(3), A4 => low_waddr_s(4), 
						  DPRA0 => low_raddr_s(0), DPRA1 => low_raddr_s(1), DPRA2 => low_raddr_s(2),
						  DPRA3 => low_raddr_s(3), DPRA4 => low_raddr_s(4), 
						  WE => wrt_en_32, WCLK => CLK, DPO => out_bus_32s(num_cell_32,j));
                out_reg_s(j) <= out_bus_32s(num_cell_32,j) when (out_en_32 = '1') else 'Z';
         end generate U21;
     end generate U18;          

    -- Generate a 16 word deep RAM cell if appropriate               
    U22 : if (num_cell_16 = 1) generate
    -- If (addrwidth > 5) need to create write enable and output enable select logic
        U23a : if (addrwidth > 6 and num_cell_32 = 1) generate
                out_en_16 <= '1' when ((rad_reg_s(addrwidth-1 downto 6) = num_cell_64) and (rad_reg_s(5) = '1') and (rad_reg_s(4) = '0')) else '0';
                wrt_en_16 <= WE when ((wad_reg_s(addrwidth-1 downto 6) = num_cell_64) and (wad_reg_s(5) = '1') and (wad_reg_s(4) = '0')) else '0';
        end generate U23a;
        U23b : if (addrwidth > 6 and num_cell_32 /= 1) generate
                out_en_16 <= '1' when ((rad_reg_s(addrwidth-1 downto 6) = num_cell_64) and (rad_reg_s(5) = '0') and (rad_reg_s(4) = '0')) else '0';
                wrt_en_16 <= WE when ((wad_reg_s(addrwidth-1 downto 6) = num_cell_64) and (wad_reg_s(5) = '0') and (wad_reg_s(4) = '0')) else '0';
        end generate U23b;
        U23c : if (addrwidth = 6 and num_cell_32 = 1) generate
                out_en_16 <= '1' when ((rad_reg_s(5) = '1') and (rad_reg_s(4) = '0')) else '0';
                wrt_en_16 <= WE when ((wad_reg_s(5) = '1') and (wad_reg_s(4) = '0')) else '0';
        end generate U23c;
        U23d : if (addrwidth = 5 and num_cell_32 /= 1) generate
                out_en_16 <= '1' when ((rad_reg_s(addrwidth-1 downto 4) = num_cell_32)) else '0';
                wrt_en_16 <= WE when ((wad_reg_s(addrwidth-1 downto 4) = num_cell_32)) else '0';
        end generate U23d;    -- If (addrwidth <= 5) no write enable or output enable select logic needed
        U24 : if (addrwidth <= 4) generate
                out_en_16 <= '1';
                wrt_en_16 <= WE;
        end generate U24;
    -- Generate the RAM cell and tri-state
        U25 : for j in (width - 1) downto 0 generate
            attribute \.ram_offset\ of URAM16 : label is "SDT" & integer'image(width) & "D" & integer'image(num_cell_64*64 + num_cell_32*32) & "W" & integer'image(j) & "E" & integer'image(get_end_depth(num_cell_64*64 + num_cell_32*32 + 16, depth)) & "X" & integer'image(j+1);
            begin
            URAM16 : RAM16X1D 
                port map (D => in_reg_s(j), A0 => low_waddr_s(0), A1 => low_waddr_s(1), A2 => low_waddr_s(2),
                          A3 => low_waddr_s(3), DPRA0 => low_raddr_s(0), DPRA1 => low_raddr_s(1), DPRA2 => low_raddr_s(2),
						  DPRA3 => low_raddr_s(3), WE => wrt_en_16, WCLK => CLK, DPO => out_bus_16s(num_cell_16,j));
                out_reg_s(j) <= out_bus_16s(num_cell_16,j) when (out_en_16 = '1') else 'Z';
        end generate U25;
    end generate U22;    
  end generate U44;
end architecture block_ram;

architecture no_rw_check of RAM_R_W is
component XRAM32X1D   port (
        DPO   : out std_ulogic;        
        SPO   : out std_ulogic;

        A0    : in std_ulogic;
        A1    : in std_ulogic;
        A2    : in std_ulogic;
        A3    : in std_ulogic;
        A4    : in std_ulogic;
        D     : in std_ulogic;
        DPRA0 : in std_ulogic;
        DPRA1 : in std_ulogic;
        DPRA2 : in std_ulogic;
        DPRA3 : in std_ulogic;
        DPRA4 : in std_ulogic;
        WCLK  : in std_ulogic;        
        WE    : in std_ulogic
       );  
end component;
component XRAM64X1D   port (
        DPO   : out std_ulogic;        
        SPO   : out std_ulogic;

        A0    : in std_ulogic;
        A1    : in std_ulogic;
        A2    : in std_ulogic;
        A3    : in std_ulogic;
        A4    : in std_ulogic;
        A5    : in std_ulogic;
        D     : in std_ulogic;
        DPRA0 : in std_ulogic;
        DPRA1 : in std_ulogic;
        DPRA2 : in std_ulogic;
        DPRA3 : in std_ulogic;
        DPRA4 : in std_ulogic;
        DPRA5 : in std_ulogic;
        WCLK  : in std_ulogic;        
        WE    : in std_ulogic
       );  
end component;
function func_init(b : boolean) return string is
begin
  if (b) then
    return("No read/write conflict check. Simulation mismatch possible !!");
  else
    return("Could not implement Block RAM. Is the read address registered using the same clock as the RAM?");
  end if;
end func_init;
function get_end_depth(size : integer ; depth : integer) return integer is
variable min_size : integer := 0;
begin
  min_size := depth;
  if (size < depth) then
    min_size := size;
  end if;
  return min_size;
end get_end_depth;
attribute generator_report : string;
attribute generator_report of no_rw_check : architecture is func_init(raddr_reg);
-- begin block ram implementation signals
type int_array is array (0 to 5) of integer;
constant width_array : int_array := (1, 2, 4, 9, 18, 36);
constant depth_array : int_array := (16384, 8192, 4096, 2048, 1024, 512);
constant div32 : integer := (width-1)/36;
constant div16 : integer := (width-1)/18;
constant div8 : integer := (width-1)/9;
constant div4 : integer := (width-1)/4;
constant div2 : integer := (width-1)/2;
constant div1 : integer := (width-1)/1;

constant bool1 : boolean := (div1 > 0);
constant bool2 : boolean := (div2 > 0);
constant bool4 : boolean := (div4 > 0);
constant bool8 : boolean := (div8 > 0);
constant bool16 : boolean := (div16 > 0);
constant bool32 : boolean := (div32 > 0);

constant div16384 : integer := (depth-1)/16384;
constant div8192 : integer := (depth-1)/8192;
constant div4096 : integer := (depth-1)/4096;
constant div2048 : integer := (depth-1)/2048;
constant div1024 : integer := (depth-1)/1024;
constant div512 : integer := (depth-1)/512;

constant bool512 : boolean := (div512 > 0);
constant bool1024 : boolean := (div1024 > 0);
constant bool2048 : boolean := (div2048 > 0);
constant bool4096 : boolean := (div4096 > 0);
constant bool8192 : boolean := (div8192 > 0);
constant bool16384 : boolean := (div16384 > 0);

constant sum_width : integer := BOOLEAN'pos(bool1) + BOOLEAN'pos(bool2) + BOOLEAN'pos(bool4) + BOOLEAN'pos(bool8) + BOOLEAN'pos(bool16);
constant sum_depth : integer := 5 - (BOOLEAN'pos(bool512) + BOOLEAN'pos(bool1024) + BOOLEAN'pos(bool2048) + BOOLEAN'pos(bool4096) + BOOLEAN'pos(bool8192));

constant w_choice_width : integer := width_array(sum_width);
constant w_choice_depth : integer := depth_array(sum_width);
constant d_choice_width : integer := width_array(sum_depth);
constant d_choice_depth : integer := depth_array(sum_depth);

constant w_width_num_cells : integer := (width-1)/w_choice_width + 1;
constant w_depth_num_cells : integer := (depth-1)/w_choice_depth + 1;

constant d_width_num_cells : integer := (width-1)/d_choice_width + 1;
constant d_depth_num_cells : integer := (depth-1)/d_choice_depth + 1;

constant w_size : integer := w_width_num_cells * w_depth_num_cells;
constant d_size : integer := d_width_num_cells * d_depth_num_cells;

constant bool_d : boolean := (d_size - w_size <= 0);
constant bool_w : boolean := not(bool_d);

constant choice_width : integer := (BOOLEAN'pos(bool_d) * d_choice_width) + (BOOLEAN'pos(bool_w) * w_choice_width);
constant choice_depth : integer := (BOOLEAN'pos(bool_d) * d_choice_depth) + (BOOLEAN'pos(bool_w) * w_choice_depth);
constant width_num_cells : integer := (BOOLEAN'pos(bool_d) *(width-1)/d_choice_width) + (BOOLEAN'pos(bool_w) * (width-1)/w_choice_width) + 1;
constant depth_num_cells : integer := (BOOLEAN'pos(bool_d) *(depth-1)/d_choice_depth) + (BOOLEAN'pos(bool_w) * (depth-1)/w_choice_depth) + 1;
type out_bus1_type is array (depth_num_cells-1 downto 0, width_num_cells-1 downto 0) of std_logic;
signal out_bus1 : out_bus1_type;                                                        -- 2D array of r_dout (input to tri-states)
type out_bus2_type is array (depth_num_cells-1 downto 0, 2*width_num_cells+1 downto 0) of std_logic;
signal out_bus2 : out_bus2_type;                                                        -- 2D array of r_dout (input to tri-states)
type out_bus4_type is array (depth_num_cells-1 downto 0, 4*width_num_cells+3 downto 0) of std_logic;
signal out_bus4 : out_bus4_type;                                                        -- 2D array of r_dout (input to tri-states)
type out_bus8_type is array (depth_num_cells-1 downto 0, 8*width_num_cells+7 downto 0) of std_logic;
signal out_bus8 : out_bus8_type;                                                        -- 2D array of r_dout (input to tri-states)
type parity_bus8_type is array (depth_num_cells-1 downto 0, width_num_cells-1 downto 0) of std_logic;
signal parity_bus8 : parity_bus8_type;                                                  -- 2D array of r_dout (input to tri-states)
type out_bus16_type is array (depth_num_cells-1 downto 0, 16*width_num_cells+15 downto 0) of std_logic;
signal out_bus16 : out_bus16_type;                                                        -- 2D array of r_dout (input to tri-states)
type parity_bus16_type is array (depth_num_cells-1 downto 0, 2*width_num_cells+1 downto 0) of std_logic;
signal parity_bus16 : parity_bus16_type;                                                -- 2D array of r_dout (input to tri-states)
type out_bus32_type is array (depth_num_cells-1 downto 0, 32*width_num_cells+31 downto 0) of std_logic;
signal out_bus32 : out_bus32_type;                                                        -- 2D array of r_dout (input to tri-states)
type parity_bus32_type is array (depth_num_cells-1 downto 0, 4*width_num_cells+3 downto 0) of std_logic;
signal parity_bus32 : parity_bus32_type;                                                -- 2D array of r_dout (input to tri-states)
signal out_en : std_logic_vector(depth_num_cells-1 downto 0);                                 -- enables for tri-states
signal wrt_en : std_logic_vector(depth_num_cells-1 downto 0);                                 -- write enables for each row of RAM cells
signal in_reg : std_logic_vector(width+35 downto 0);                                   -- used to register DIN 
signal out_reg : std_logic_vector(width+35 downto 0);                                  -- used to register DOUT
signal out_reg1 : std_logic_vector(width-1 downto 0);                                 -- used to choose between DIN and output of Block RAM
signal rad_reg : std_logic_vector(addrwidth-1 downto 0);                               -- used to register RADDR
signal wad_reg : std_logic_vector(addrwidth-1 downto 0);                               -- used to register WADDR
signal low_raddr : std_logic_vector(13 downto 0);                                       -- raddr bits input to RAM cells (4 bits required)
signal low_waddr : std_logic_vector(13 downto 0);                                       -- waddr bits input to RAM cells (4 bits required)
signal r_addr_reg : std_logic_vector(addrwidth-1 downto 0);
-- end block ram implementation signals
-- begin select ram implementation signals
function get_num_64(depth: integer) return integer is
variable val : integer := 0;
begin
  val := depth/64;
  if ((depth mod 64) > 48) then
    val := val + 1;
  end if;
  return val;
end get_num_64;
function get_leftover_32(depth : integer) return integer is
begin
  return(depth mod 64);
end get_leftover_32;
function get_leftover(depth : integer; max : integer) return integer is
variable val : integer := 0;
begin
  if (depth - max >= 0) then
    val := depth - max;
  else
    val := depth;
  end if;
  return(val);
end get_leftover;
function get_num_32(depth : integer) return integer is
variable val : integer := 0;
begin
  if (depth <= 48 and depth > 16) then
     val := 1;
  end if;
  return val;
end get_num_32;
function get_num_16(depth : integer) return integer is
variable val : integer := 0;
begin
  if (depth <= 16 and depth > 0) then
     val := 1;
  end if;
  return val;
end get_num_16;
constant num_cell_64 : integer := get_num_64(depth);
constant leftover_32 : integer := get_leftover_32(depth);
constant num_cell_32 : integer := get_num_32(leftover_32);
constant leftover_16 : integer := get_leftover(leftover_32, 32);
constant num_cell_16 : integer := get_num_16(leftover_16);

type out_bus_type_64s is array (num_cell_64 downto 0, width-1 downto 0) of std_logic;
type out_bus_type_32s is array (num_cell_32 downto 0, width-1 downto 0) of std_logic;
type out_bus_type_16s is array (num_cell_16 downto 0, width-1 downto 0) of std_logic;
signal out_bus_64s : out_bus_type_64s;                                                        -- 2D array of dout (input to tri-states)
signal out_bus_32s : out_bus_type_32s;                                                        -- 2D array of dout (input to tri-states)
signal out_bus_16s : out_bus_type_16s;                                                        -- 2D array of dout (input to tri-states)
signal out_en_s : std_logic_vector(num_cell_64 downto 0);                                 -- enables for tri-states
signal out_en_32 : std_logic;
signal out_en_16 : std_logic;
signal wrt_en_s : std_logic_vector(num_cell_64 downto 0);                                 -- write enables for each row of RAM cells
signal wrt_en_32 : std_logic;
signal wrt_en_16 : std_logic;
signal in_reg_s : std_logic_vector(width-1 downto 0);                                   -- used to register DIN 
signal out_reg_s : std_logic_vector(width-1 downto 0);                                  -- used to register DOUT
signal rad_reg_s : std_logic_vector(addrwidth-1 downto 0);                               -- used to register ADDR
signal wad_reg_s : std_logic_vector(addrwidth-1 downto 0);                               -- used to register ADDR
signal low_raddr_s : std_logic_vector(5 downto 0);                                       -- addr bits input to RAM cells (4 bits required)
signal low_waddr_s : std_logic_vector(5 downto 0);                                       -- addr bits input to RAM cells (4 bits required)
-- end select ram implementation signals
attribute \.ram_offset\ : string;

begin
  U43: if (raddr_reg) generate -- generate block ram
    -- If addrwidth < choice_width assign '0' to unused bits
    U0  : if (addrwidth = 1) generate
	    low_raddr <= "0000000000000" & rad_reg(0);
	    low_waddr <= "0000000000000" & wad_reg(0);
	end generate U0;
    U1  : if (addrwidth = 2) generate
		low_raddr <= "000000000000" & rad_reg(1 downto 0);
	    low_waddr <= "000000000000" & wad_reg(1 downto 0);
	end generate U1;
    U2  : if (addrwidth = 3) generate
		low_raddr <= "00000000000" & rad_reg(2 downto 0);
	    low_waddr <= "00000000000" & wad_reg(2 downto 0);
	end generate U2;
    U3  : if (addrwidth = 4) generate
		low_raddr <= "0000000000" & rad_reg(3 downto 0);
	    low_waddr <= "0000000000" & wad_reg(3 downto 0);
	end generate U3;
    U4  : if (addrwidth = 5) generate
	    low_raddr <= "000000000" & rad_reg(4 downto 0);
	    low_waddr <= "000000000" & wad_reg(4 downto 0);
	end generate U4;
    U5  : if (addrwidth = 6) generate
	    low_raddr <= "00000000" & rad_reg(5 downto 0);
		low_waddr <= "00000000" & wad_reg(5 downto 0);
	end generate U5;
    U6  : if (addrwidth = 7) generate
	    low_raddr <= "0000000" & rad_reg(6 downto 0);
		low_waddr <= "0000000" & wad_reg(6 downto 0);
	end generate U6;
    U7  : if (addrwidth = 8) generate
	    low_raddr <= "000000" & rad_reg(7 downto 0);
		low_waddr <= "000000" & wad_reg(7 downto 0);
	end generate U7;
    U8  : if (addrwidth = 9) generate
	    low_raddr <= "00000" & rad_reg(8 downto 0);
		low_waddr <= "00000" & wad_reg(8 downto 0);
	end generate U8;
    U9  : if (addrwidth = 10) generate
	    low_raddr <= "0000" & rad_reg(9 downto 0);
		low_waddr <= "0000" & wad_reg(9 downto 0);
	end generate U9;
    U10  : if (addrwidth = 11) generate
	    low_raddr <= "000" & rad_reg(10 downto 0);
		low_waddr <= "000" & wad_reg(10 downto 0);
	end generate U10;
    U11  : if (addrwidth = 12) generate
	    low_raddr <= "00" & rad_reg(11 downto 0);
		low_waddr <= "00" & wad_reg(11 downto 0);
	end generate U11;
    U12  : if (addrwidth = 13) generate
	    low_raddr <= '0' & rad_reg(12 downto 0);
		low_waddr <= '0' & wad_reg(12 downto 0);
	end generate U12;
    U13  : if (addrwidth > 13) generate
	    low_raddr <= rad_reg(13 downto 0);
	    low_waddr <= wad_reg(13 downto 0);
	end generate U13;

    -- If (din_reg) register DIN using CLK
    U14  : if (din_reg) generate
        process (CLK, DIN) begin
            if (CLK = '1' and CLK'event) then
                in_reg <= ("000000000000000000000000000000000000" & DIN);
            end if;
        end process;
	end generate U14;
    U15  : if (not din_reg) generate
            in_reg <= ("000000000000000000000000000000000000" & DIN);
	end generate U15;

    -- If (rdout_reg) register R_DOUT using R_OCLK
    U16  : if (dout_reg) generate
        process (OCLK, out_reg1) begin
            if (OCLK = '1' and OCLK'event) then
                DOUT <= out_reg1;
            end if;
        end process;
        end generate U16;
    U17  : if (not dout_reg) generate
            DOUT <= out_reg1;
	end generate U17;

    -- If (raddr_reg) register RADDR using OCLK
    U16r  : if (raddr_reg) generate
--        process (OCLK, RADDR) begin
--            if (OCLK = '1' and OCLK'event) then
--                rad_reg <= RADDR(addrwidth-1 downto 0);
--            end if;
--        end process;
--	end generate U16r;
--    U17r : if (not raddr_reg) generate
            rad_reg <= RADDR;
	end generate U16r;

	-- If (waddr_reg) register WADDR using W_OCLK
    U16w  : if (waddr_reg) generate
        process (CLK, WADDR) begin
            if (CLK = '1' and CLK'event) then
                wad_reg <= WADDR(addrwidth-1 downto 0);
            end if;
        end process;
	end generate U16w;
    U17w : if (not waddr_reg) generate
            wad_reg <= WADDR;
	end generate U17w;

    -- Extra logic for Dual port case
	-- Do not need this for nordwrchk case
--	Ureg : process(CLK) begin
--	  if (CLK'EVENT and CLK = '1') then
--	   DIN_tmp <= DIN;
--	   RADDR_tmp <= RADDR;
--	   WADDR_tmp <= WADDR;
--	   WE_tmp <= WE;
--	  end if;
--	end process;

	-- If Read Address = Write Address, bypass DIN to output if WE is enabled
	Umux : process(out_reg)
	  begin
--	    if (WADDR_tmp = RADDR_tmp and WE_tmp = '1') then
--		  out_reg1 <= DIN_tmp;
--		else
		  out_reg1 <= out_reg(width-1 downto 0);
--		end if;
	end process;
	    
    -- Generate the RAM cells and select logic for RAMB16_S1_S1
	U18 : if (choice_width = 1) generate
	-- fix for call 13887, select of tristate not being registered
	   Uchk: if (addrwidth > 14) generate
        uclk : process(CLK)
         begin
          if (CLK'event and CLK = '1') then
            r_addr_reg(addrwidth-1 downto 14) <= RADDR(addrwidth-1 downto 14);
          end if;
        end process uclk;
	  end generate Uchk;
    	U19 : for i in (depth_num_cells - 1) downto 0 generate
	-- If (addrwidth > 14) need to create write enable and output enable select logic
        	U20 : if (addrwidth > 14) generate
	-- fix for call 13887, select of tristate not being registered
				out_en(i) <= '1' when (r_addr_reg(addrwidth-1 downto 14) = i) else '0';
                wrt_en(i) <= WE when (wad_reg(addrwidth-1 downto 14) = i) else '0';
        	end generate U20;
	-- If (addrwidth <= 14) no write enable or output enable select logic needed
 	    	U21 : if (addrwidth <= 14) generate
				out_en(i) <= '1';
                wrt_en(i) <= WE;
        	end generate U21;
	-- Generate the RAM cells and tri-states
        	U22 : for j in (width_num_cells - 1) downto 0 generate
                attribute \.ram_offset\ of BRAM_16384X1D : label is "W";
                begin
            	BRAM_16384X1D : RAMB16_S1_S1
	            port map (DIA(0) => in_reg(j), ADDRA => low_waddr(13 downto 0), DIB => "0", ADDRB => low_raddr(13 downto 0),
				ENA => '1', SSRA => '0', WEA => wrt_en(i), CLKA => CLK, ENB => '1', SSRB => '0', WEB => '0', CLKB => CLK,
			    DOA => open, DOB(0) => out_bus1(i,j));

                out_reg(j) <= out_bus1(i,j) when (out_en(i) = '1') else 'Z';
        	end generate U22;
     	end generate U19;
    end generate U18;    
      
    -- Generate the RAM cells and select logic for RAMB16_S2_S2
	U23 : if (choice_width = 2) generate
	-- fix for call 13887, select of tristate not being registered
	  Uchk : if (addrwidth > 13) generate
        uclk : process(CLK)
         begin
          if (CLK'event and CLK = '1') then
            r_addr_reg(addrwidth-1 downto 13) <= RADDR(addrwidth-1 downto 13);
          end if;
        end process uclk;
	  end generate Uchk;
    	U24 : for i in (depth_num_cells - 1) downto 0 generate
	-- If (addrwidth > 13) need to create write enable and output enable select logic
        	U25 : if (addrwidth > 13) generate
	-- fix for call 13887, select of tristate not being registered
                out_en(i) <= '1' when (r_addr_reg(addrwidth-1 downto 13) = i) else '0';
                wrt_en(i) <= WE when (wad_reg(addrwidth-1 downto 13) = i) else '0';
        	end generate U25;
	-- If (addrwidth <= 13) no write enable or output enable select logic needed
 	    	U26 : if (addrwidth <= 13) generate
	            out_en(i) <= '1';
                wrt_en(i) <= WE;
        	end generate U26;
	-- Generate the RAM cells and tri-states
        	U27 : for j in (width_num_cells - 1) downto 0 generate
                attribute \.ram_offset\ of BRAM_8192X2D : label is "W";
                begin
            	BRAM_8192X2D : RAMB16_S2_S2
	            port map (DIA => in_reg(2*j+1 downto 2*j), ADDRA => low_waddr(12 downto 0), DIB => "00", ADDRB => low_raddr(12 downto 0),
			    ENA => '1', SSRA => '0', WEA => wrt_en(i), CLKA => CLK, ENB => '1', SSRB => '0', WEB => '0', CLKB => CLK,
			    DOA => open, DOB(1) => out_bus2(i,2*j+1), DOB(0) => out_bus2(i, 2*j));
                out_reg(2*j) <= out_bus2(i,2*j) when (out_en(i) = '1') else 'Z';
                out_reg(2*j+1) <= out_bus2(i,2*j+1) when (out_en(i) = '1') else 'Z';
        	end generate U27;
     	end generate U24;
    end generate U23;  

	    -- Generate the RAM cells and select logic for RAMB16_S4_S4
	U28 : if (choice_width = 4) generate
	-- fix for call 13887, select of tristate not being registered
	  Uchk: if (addrwidth > 12) generate 
        uclk : process(CLK)
         begin
          if (CLK'event and CLK = '1') then
            r_addr_reg(addrwidth-1 downto 12) <= RADDR(addrwidth-1 downto 12);
          end if;
        end process uclk;
	  end generate Uchk;
    	U29 : for i in (depth_num_cells - 1) downto 0 generate
	-- If (addrwidth > 12) need to create write enable and output enable select logic
        	U30 : if (addrwidth > 12) generate
	-- fix for call 13887, select of tristate not being registered
                out_en(i) <= '1' when (r_addr_reg(addrwidth-1 downto 12) = i) else '0';
                wrt_en(i) <= WE when (wad_reg(addrwidth-1 downto 12) = i) else '0';
        	end generate U30;
	-- If (addrwidth <= 12) no write enable or output enable select logic needed
 	    	U31 : if (addrwidth <= 12) generate
				out_en(i) <= '1';
                wrt_en(i) <= WE;
        	end generate U31;
	-- Generate the RAM cells and tri-states
        	U32 : for j in (width_num_cells - 1) downto 0 generate
                attribute \.ram_offset\ of BRAM_4096X4D : label is "W";
                begin
            	BRAM_4096X4D : RAMB16_S4_S4
	            port map (DIA => in_reg(4*j+3 downto 4*j), ADDRA => low_waddr(11 downto 0), DIB => "0000", ADDRB => low_raddr(11 downto 0),
				ENA => '1', SSRA => '0', WEA => wrt_en(i), CLKA => CLK, ENB => '1', SSRB => '0', WEB => '0', CLKB => CLK,
				DOA => open, DOB(3) => out_bus4(i, 4*j+3), DOB(2) => out_bus4(i,4*j+2), 
				DOB(1) => out_bus4(i,4*j+1), DOB(0) => out_bus4(i, 4*j));
                out_reg(4*j) <= out_bus4(i,4*j) when (out_en(i) = '1') else 'Z';
                out_reg(4*j+1) <= out_bus4(i,4*j+1) when (out_en(i) = '1') else 'Z';
                out_reg(4*j+2) <= out_bus4(i,4*j+2) when (out_en(i) = '1') else 'Z';
                out_reg(4*j+3) <= out_bus4(i,4*j+3) when (out_en(i) = '1') else 'Z';

        	end generate U32;
     	end generate U29;
    end generate U28;

	    -- Generate the RAM cells and select logic for RAMB16_S9_S9
	U33 : if (choice_width = 9) generate
	-- fix for call 13887, select of tristate not being registered
	  Uchk : if (addrwidth > 11) generate
        uclk : process(CLK)
         begin
          if (CLK'event and CLK = '1') then
            r_addr_reg(addrwidth-1 downto 11) <= RADDR(addrwidth-1 downto 11);
          end if;
        end process uclk;
	  end generate Uchk;
    	U34 : for i in (depth_num_cells - 1) downto 0 generate
	-- If (addrwidth > 11) need to create write enable and output enable select logic
        	U35 : if (addrwidth > 11) generate
	-- fix for call 13887, select of tristate not being registered
                out_en(i) <= '1' when (r_addr_reg(addrwidth-1 downto 11) = i) else '0';
                wrt_en(i) <= WE when (wad_reg(addrwidth-1 downto 11) = i) else '0';
        	end generate U35;
	-- If (addrwidth <= 11) no write enable or output enable select logic needed
 	    	U36 : if (addrwidth <= 11) generate
	            out_en(i) <= '1';
                wrt_en(i) <= WE;
        	end generate U36;
	-- Generate the RAM cells and tri-states
        	U37 : for j in (width_num_cells - 1) downto 0 generate
                attribute \.ram_offset\ of BRAM_2048X8D : label is "W";
                begin
            	BRAM_2048X8D : RAMB16_S9_S9
                  port map (DIA => in_reg(9*j+7 downto 9*j), ADDRA => low_waddr(10 downto 0), DIB => "00000000", ADDRB => low_raddr(10 downto 0),
				ENA => '1', SSRA => '0', WEA => wrt_en(i), CLKA => CLK, ENB => '1', SSRB => '0', WEB => '0', CLKB => CLK, 
				DOA => open, DOB(7) => out_bus8(i,8*j+7), DOB(6) => out_bus8(i,8*j+6), 
				DOB(5) => out_bus8(i,8*j+5), DOB(4) => out_bus8(i,8*j+4), DOB(3) => out_bus8(i,8*j+3), 
				DOB(2) => out_bus8(i,8*j+2), DOB(1) => out_bus8(i,8*j+1), DOB(0) => out_bus8(i,8*j), 
                            DIPA(0) => in_reg(9*j+8), DIPB => "0", DOPA => open, DOPB(0) => parity_bus8(i,j));
                out_reg(9*j) <= out_bus8(i,8*j) when (out_en(i) = '1') else 'Z';
                out_reg(9*j+1) <= out_bus8(i,8*j+1) when (out_en(i) = '1') else 'Z';
                out_reg(9*j+2) <= out_bus8(i,8*j+2) when (out_en(i) = '1') else 'Z';
                out_reg(9*j+3) <= out_bus8(i,8*j+3) when (out_en(i) = '1') else 'Z';
                out_reg(9*j+4) <= out_bus8(i,8*j+4) when (out_en(i) = '1') else 'Z';
                out_reg(9*j+5) <= out_bus8(i,8*j+5) when (out_en(i) = '1') else 'Z';
                out_reg(9*j+6) <= out_bus8(i,8*j+6) when (out_en(i) = '1') else 'Z';
                out_reg(9*j+7) <= out_bus8(i,8*j+7) when (out_en(i) = '1') else 'Z';
                out_reg(9*j+8) <= parity_bus8(i,j) when (out_en(i) = '1') else 'Z';
        	end generate U37;
     	end generate U34;
    end generate U33;

	    -- Generate the RAM cells and select logic for RAMB16_S18_S18
	U38 : if (choice_width = 18) generate
	-- fix for call 13887, select of tristate not being registered
	   Uchk : if (addrwidth > 10) generate
        uclk : process(CLK)
         begin
          if (CLK'event and CLK = '1') then
            r_addr_reg(addrwidth-1 downto 10) <= RADDR(addrwidth-1 downto 10);
          end if;
        end process uclk;
	   end generate Uchk;
    	U39 : for i in (depth_num_cells - 1) downto 0 generate
	-- If (addrwidth > 10) need to create write enable and output enable select logic
        	U40 : if (addrwidth > 10) generate
	-- fix for call 13887, select of tristate not being registered
                out_en(i) <= '1' when (r_addr_reg(addrwidth-1 downto 10) = i) else '0';
                wrt_en(i) <= WE when (wad_reg(addrwidth-1 downto 10) = i) else '0';
        	end generate U40;
	-- If (addrwidth <= 10) no write enable or output enable select logic needed
 	    	U41 : if (addrwidth <= 10) generate
	            out_en(i) <= '1';
                wrt_en(i) <= WE;
        	end generate U41;
	-- Generate the RAM cells and tri-states
        	U42 : for j in (width_num_cells - 1) downto 0 generate
                attribute \.ram_offset\ of BRAM_1024X16D : label is "W";
                begin
            	BRAM_1024X16D : RAMB16_S18_S18
                  port map (DIA => in_reg(18*j+15 downto 18*j), ADDRA => low_waddr(9 downto 0), DIB => "0000000000000000", ADDRB => low_raddr(9 downto 0),
				ENA => '1', SSRA => '0', WEA => wrt_en(i), CLKA => CLK, ENB => '1', SSRB => '0', WEB => '0', CLKB => CLK, 
				DOA => open, DOB(15) => out_bus16(i,16*j+15), DOB(14) => out_bus16(i,16*j+14), 
				DOB(13) => out_bus16(i,16*j+13), DOB(12) => out_bus16(i,16*j+12), DOB(11) => out_bus16(i,16*j+11), 
				DOB(10) => out_bus16(i,16*j+10), DOB(9) => out_bus16(i,16*j+9), DOB(8) => out_bus16(i,16*j+8), 
				DOB(7) => out_bus16(i,16*j+7), DOB(6) => out_bus16(i,16*j+6), DOB(5) => out_bus16(i,16*j+5), 
				DOB(4) => out_bus16(i,16*j+4), DOB(3) => out_bus16(i,16*j+3), DOB(2) => out_bus16(i,16*j+2), 
				DOB(1) => out_bus16(i,16*j+1), DOB(0) => out_bus16(i,16*j), 
                            DIPA => in_reg(18*j+17 downto 18*j+16), DIPB => "00", DOPA => open,
                            DOPB(1) => parity_bus16(i,2*j+1), DOPB(0) => parity_bus16(i,2*j));
                out_reg(18*j) <= out_bus16(i,16*j) when (out_en(i) = '1') else 'Z';
                out_reg(18*j+1) <= out_bus16(i,16*j+1) when (out_en(i) = '1') else 'Z';
                out_reg(18*j+2) <= out_bus16(i,16*j+2) when (out_en(i) = '1') else 'Z';
                out_reg(18*j+3) <= out_bus16(i,16*j+3) when (out_en(i) = '1') else 'Z';
                out_reg(18*j+4) <= out_bus16(i,16*j+4) when (out_en(i) = '1') else 'Z';
                out_reg(18*j+5) <= out_bus16(i,16*j+5) when (out_en(i) = '1') else 'Z';
                out_reg(18*j+6) <= out_bus16(i,16*j+6) when (out_en(i) = '1') else 'Z';
                out_reg(18*j+7) <= out_bus16(i,16*j+7) when (out_en(i) = '1') else 'Z';
                out_reg(18*j+8) <= out_bus16(i,16*j+8) when (out_en(i) = '1') else 'Z';
                out_reg(18*j+9) <= out_bus16(i,16*j+9) when (out_en(i) = '1') else 'Z';
                out_reg(18*j+10) <= out_bus16(i,16*j+10) when (out_en(i) = '1') else 'Z';
                out_reg(18*j+11) <= out_bus16(i,16*j+11) when (out_en(i) = '1') else 'Z';
                out_reg(18*j+12) <= out_bus16(i,16*j+12) when (out_en(i) = '1') else 'Z';
                out_reg(18*j+13) <= out_bus16(i,16*j+13) when (out_en(i) = '1') else 'Z';
                out_reg(18*j+14) <= out_bus16(i,16*j+14) when (out_en(i) = '1') else 'Z';
                out_reg(18*j+15) <= out_bus16(i,16*j+15) when (out_en(i) = '1') else 'Z';
                out_reg(18*j+16) <= parity_bus16(i,2*j) when (out_en(i) = '1') else 'Z';
                out_reg(18*j+17) <= parity_bus16(i,2*j+1) when (out_en(i) = '1') else 'Z';
        	end generate U42;
     	end generate U39;
    end generate U38;

	    -- Generate the RAM cells and select logic for RAMB16_S36_S36
	U38a : if (choice_width = 36) generate
	-- fix for call 13887, select of tristate not being registered
	   Uchk : if (addrwidth > 9) generate
	    uclk : process(CLK)
		 begin
		  if (CLK'event and CLK = '1') then
		    r_addr_reg(addrwidth-1 downto 9) <= RADDR(addrwidth-1 downto 9);
		  end if;
		end process uclk;
	   end generate Uchk;
	    U39a : for i in (depth_num_cells - 1) downto 0 generate
	-- If (addrwidth > 9) need to create write enable and output enable select logic
			U40a : if (addrwidth > 9) generate
	-- fix for call 13887, select of tristate not being registered
				out_en(i) <= '1' when (r_addr_reg(addrwidth-1 downto 9) = i) else '0';
				wrt_en(i) <= WE when (wad_reg(addrwidth-1 downto 9) = i) else '0';
			end generate U40a;
	-- If (addrwidth <= 9) no write enable or output enable select logic needed
			U41a : if (addrwidth <= 9) generate
				out_en(i) <= '1';
				wrt_en(i) <= WE;
			end generate U41a;
	-- Generate the RAM cells and tri-states
			U42a : for j in (width_num_cells - 1) downto 0 generate
                attribute \.ram_offset\ of BRAM_512X32D : label is "W";
                begin
				BRAM_512X32D : RAMB16_S36_S36
                                  port map (DIA => in_reg(36*j+31 downto 36*j), ADDRA => low_waddr(8 downto 0), DIB => "00000000000000000000000000000000", ADDRB => low_raddr(8 downto 0),
				ENA => '1', SSRA => '0', WEA => wrt_en(i), CLKA => CLK, ENB => '1', SSRB => '0', WEB => '0', CLKB => CLK,
				DOA => open, DOB(31) => out_bus32(i,32*j+31), DOB(30) => out_bus32(i,32*j+30),
				DOB(29) => out_bus32(i,32*j+29), DOB(28) => out_bus32(i,32*j+28), DOB(27) => out_bus32(i,32*j+27),
				DOB(26) => out_bus32(i,32*j+26), DOB(25) => out_bus32(i,32*j+25), DOB(24) => out_bus32(i,32*j+24),
				DOB(23) => out_bus32(i,32*j+23), DOB(22) => out_bus32(i,32*j+22), DOB(21) => out_bus32(i,32*j+21),
				DOB(20) => out_bus32(i,32*j+20), DOB(19) => out_bus32(i,32*j+19), DOB(18) => out_bus32(i,32*j+18),
				DOB(17) => out_bus32(i,32*j+17), DOB(16) => out_bus32(i,32*j+16), DOB(15) => out_bus32(i,32*j+15),
				DOB(14) => out_bus32(i,32*j+14), DOB(13) => out_bus32(i,32*j+13), DOB(12) => out_bus32(i,32*j+12),
				DOB(11) => out_bus32(i,32*j+11), DOB(10) => out_bus32(i,32*j+10), DOB(9) => out_bus32(i,32*j+9),
				DOB(8) => out_bus32(i,32*j+8), DOB(7) => out_bus32(i,32*j+7), DOB(6) => out_bus32(i,32*j+6),
				DOB(5) => out_bus32(i,32*j+5), DOB(4) => out_bus32(i,32*j+4), DOB(3) => out_bus32(i,32*j+3),
				DOB(2) => out_bus32(i,32*j+2), DOB(1) => out_bus32(i,32*j+1), DOB(0) => out_bus32(i,32*j),
                                            DIPA => in_reg(36*j+35 downto 36*j+32), DIPB => "0000", DOPA => open,
                                            DOPB(3) => parity_bus32(i,4*j+3), DOPB(2) => parity_bus32(i,4*j+2),
                                            DOPB(1) => parity_bus32(i,4*j+1), DOPB(0) => parity_bus32(i,4*j));
				out_reg(36*j) <= out_bus32(i,32*j) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+1) <= out_bus32(i,32*j+1) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+2) <= out_bus32(i,32*j+2) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+3) <= out_bus32(i,32*j+3) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+4) <= out_bus32(i,32*j+4) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+5) <= out_bus32(i,32*j+5) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+6) <= out_bus32(i,32*j+6) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+7) <= out_bus32(i,32*j+7) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+8) <= out_bus32(i,32*j+8) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+9) <= out_bus32(i,32*j+9) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+10) <= out_bus32(i,32*j+10) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+11) <= out_bus32(i,32*j+11) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+12) <= out_bus32(i,32*j+12) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+13) <= out_bus32(i,32*j+13) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+14) <= out_bus32(i,32*j+14) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+15) <= out_bus32(i,32*j+15) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+16) <= out_bus32(i,32*j+16) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+17) <= out_bus32(i,32*j+17) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+18) <= out_bus32(i,32*j+18) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+19) <= out_bus32(i,32*j+19) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+20) <= out_bus32(i,32*j+20) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+21) <= out_bus32(i,32*j+21) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+22) <= out_bus32(i,32*j+22) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+23) <= out_bus32(i,32*j+23) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+24) <= out_bus32(i,32*j+24) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+25) <= out_bus32(i,32*j+25) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+26) <= out_bus32(i,32*j+26) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+27) <= out_bus32(i,32*j+27) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+28) <= out_bus32(i,32*j+28) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+29) <= out_bus32(i,32*j+29) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+30) <= out_bus32(i,32*j+30) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+31) <= out_bus32(i,32*j+31) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+32) <= parity_bus32(i,4*j) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+33) <= parity_bus32(i,4*j+1) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+34) <= parity_bus32(i,4*j+2) when (out_en(i) = '1') else 'Z';
				out_reg(36*j+35) <= parity_bus32(i,4*j+3) when (out_en(i) = '1') else 'Z';
			end generate U42a;
		end generate U39a;
	end generate U38a;
  end generate U43;

  U44 : if (not raddr_reg) generate -- generate select ram
    -- If addrwidth < 5 assign '0' to unused bits
    U0  : if (addrwidth = 1) generate
        low_raddr_s <= "00000" & rad_reg_s(0);
        low_waddr_s <= "00000" & wad_reg_s(0);
    end generate U0;
    U1  : if (addrwidth = 2) generate
        low_raddr_s <= "0000" & rad_reg_s(1 downto 0);
        low_waddr_s <= "0000" & wad_reg_s(1 downto 0);
    end generate U1;
    U2  : if (addrwidth = 3) generate
        low_raddr_s <= "000" & rad_reg_s(2 downto 0);
        low_waddr_s <= "000" & wad_reg_s(2 downto 0);
    end generate U2;
    U3  : if (addrwidth = 4) generate
        low_raddr_s <= "00" & rad_reg_s(3 downto 0);
        low_waddr_s <= "00" & wad_reg_s(3 downto 0);
    end generate U3;
	U4	: if (addrwidth = 5) generate
		low_raddr_s <= '0' & rad_reg_s(4 downto 0);
		low_waddr_s <= '0' & wad_reg_s(4 downto 0);
	end generate U4;
    U5  : if (addrwidth > 5) generate
        low_raddr_s <= rad_reg_s(5 downto 0);
        low_waddr_s <= wad_reg_s(5 downto 0);
    end generate U5;

    -- If (din_reg) register DIN using CLK
    U6  : if (din_reg) generate
        process (CLK, DIN) begin
            if (CLK = '1' and CLK'event) then
                in_reg_s <= DIN;
            end if;
        end process;
    end generate U6;
    U7  : if (not din_reg) generate
            in_reg_s <= DIN;
    end generate U7;

    -- If (dout_reg) register DOUT using OCLK
    U8  : if (dout_reg) generate
        process (OCLK, out_reg_s) begin
            if (OCLK = '1' and OCLK'event) then
                DOUT <= out_reg_s;
            end if;
        end process;
    end generate U8;
    U9  : if (not dout_reg) generate
            DOUT <= out_reg_s;
    end generate U9;

    -- If (addr_reg) register ADDR using CLK
    U10  : if (raddr_reg) generate
        process (CLK, RADDR) begin
            if (CLK = '1' and CLK'event) then
                rad_reg_s <= RADDR(addrwidth-1 downto 0);
            end if;
        end process;
    end generate U10;
    U11 : if (not raddr_reg) generate
            rad_reg_s <= RADDR;
    end generate U11;

    -- If (addr_reg) register ADDR using CLK
    U12  : if (waddr_reg) generate
        process (CLK, WADDR) begin
            if (CLK = '1' and CLK'event) then
                wad_reg_s <= WADDR(addrwidth-1 downto 0);
            end if;
        end process;
    end generate U12;
    U13 : if (not waddr_reg) generate
            wad_reg_s <= WADDR;
    end generate U13;
        
    -- Generate the RAM cells and select logic
    U14 : for i in (num_cell_64 - 1) downto 0 generate
    -- If (addrwidth > 5) need to create write enable and output enable select logic
        U15 : if (addrwidth > 6) generate
                out_en_s(i) <= '1' when (rad_reg_s(addrwidth-1 downto 6) = i) else '0';
                wrt_en_s(i) <= WE when (wad_reg_s(addrwidth-1 downto 6) = i) else '0';
        end generate U15;
    -- If (addrwidth <= 5) no write enable or output enable select logic needed
        U16 : if (addrwidth <= 6) generate
                out_en_s(i) <= '1';
                wrt_en_s(i) <= WE;
        end generate U16;
    -- Generate the RAM cells and tri-states
        U17 : for j in (width - 1) downto 0 generate
            attribute \.ram_offset\ of URAM64 : label is "SDT" & integer'image(width) & "D" & integer'image(i*64) & "W" & integer'image(j) & "E" & integer'image(get_end_depth((i+1)*64, depth)) & "X" & integer'image(j+1);
            begin
            URAM64 : XRAM64X1D 
                port map (D => in_reg_s(j), A0 => low_waddr_s(0), A1 => low_waddr_s(1), A2 => low_waddr_s(2),
                          A3 => low_waddr_s(3), A4 => low_waddr_s(4), A5 => low_waddr_s(5), 
						  DPRA0 => low_raddr_s(0), DPRA1 => low_raddr_s(1), DPRA2 => low_raddr_s(2),
						  DPRA3 => low_raddr_s(3), DPRA4 => low_raddr_s(4), DPRA5 => low_raddr_s(5), 
						  WE => wrt_en_s(i), WCLK => CLK, DPO => out_bus_64s(i,j));
                out_reg_s(j) <= out_bus_64s(i,j) when (out_en_s(i) = '1') else 'Z';
        end generate U17;
     end generate U14;            
      
    -- Generate a 32 word deep RAM cell if appropriate               
    U18 : if (num_cell_32 = 1) generate
    -- If (addrwidth > 7) need to create write enable and output enable select logic
        U19a : if (addrwidth > 6) generate
                out_en_32 <= '1' when ((rad_reg_s(addrwidth-1 downto 6) = num_cell_64) and (rad_reg_s(5) = '0')) else '0';
                wrt_en_32 <= WE when ((wad_reg_s(addrwidth-1 downto 6) = num_cell_64) and (wad_reg_s(5) = '0')) else '0';
        end generate U19a;
        U19b : if (addrwidth = 6 and num_cell_64 = 0) generate
                out_en_32 <= '1' when ((rad_reg_s(5) = '0')) else '0';
                wrt_en_32 <= WE when ((wad_reg_s(5) = '0')) else '0';
        end generate U19b;    -- If (addrwidth <= 5) no write enable or output enable select logic needed
        U20 : if (addrwidth <= 5) generate
                out_en_32 <= '1';
                wrt_en_32 <= WE;
        end generate U20;
    -- Generate the RAM cell and tri-state
        U21 : for j in (width - 1) downto 0 generate
            attribute \.ram_offset\ of URAM32 : label is "SDT" & integer'image(width) & "D" & integer'image(num_cell_64*64) & "W" & integer'image(j) & "E" & integer'image(get_end_depth(num_cell_64*64 + 32, depth)) & "X" & integer'image(j+1);
            begin
            URAM32 : XRAM32X1D 
                port map (D => in_reg_s(j), A0 => low_waddr_s(0), A1 => low_waddr_s(1), A2 => low_waddr_s(2),
                          A3 => low_waddr_s(3), A4 => low_waddr_s(4), 
						  DPRA0 => low_raddr_s(0), DPRA1 => low_raddr_s(1), DPRA2 => low_raddr_s(2),
						  DPRA3 => low_raddr_s(3), DPRA4 => low_raddr_s(4), 
						  WE => wrt_en_32, WCLK => CLK, DPO => out_bus_32s(num_cell_32,j));
                out_reg_s(j) <= out_bus_32s(num_cell_32,j) when (out_en_32 = '1') else 'Z';
         end generate U21;
     end generate U18;          

    -- Generate a 16 word deep RAM cell if appropriate               
    U22 : if (num_cell_16 = 1) generate
    -- If (addrwidth > 5) need to create write enable and output enable select logic
        U23a : if (addrwidth > 6 and num_cell_32 = 1) generate
                out_en_16 <= '1' when ((rad_reg_s(addrwidth-1 downto 6) = num_cell_64) and (rad_reg_s(5) = '1') and (rad_reg_s(4) = '0')) else '0';
                wrt_en_16 <= WE when ((wad_reg_s(addrwidth-1 downto 6) = num_cell_64) and (wad_reg_s(5) = '1') and (wad_reg_s(4) = '0')) else '0';
        end generate U23a;
        U23b : if (addrwidth > 6 and num_cell_32 /= 1) generate
                out_en_16 <= '1' when ((rad_reg_s(addrwidth-1 downto 6) = num_cell_64) and (rad_reg_s(5) = '0') and (rad_reg_s(4) = '0')) else '0';
                wrt_en_16 <= WE when ((wad_reg_s(addrwidth-1 downto 6) = num_cell_64) and (wad_reg_s(5) = '0') and (wad_reg_s(4) = '0')) else '0';
        end generate U23b;
        U23c : if (addrwidth = 6 and num_cell_32 = 1) generate
                out_en_16 <= '1' when ((rad_reg_s(5) = '1') and (rad_reg_s(4) = '0')) else '0';
                wrt_en_16 <= WE when ((wad_reg_s(5) = '1') and (wad_reg_s(4) = '0')) else '0';
        end generate U23c;
        U23d : if (addrwidth = 5 and num_cell_32 /= 1) generate
                out_en_16 <= '1' when ((rad_reg_s(addrwidth-1 downto 4) = num_cell_32)) else '0';
                wrt_en_16 <= WE when ((wad_reg_s(addrwidth-1 downto 4) = num_cell_32)) else '0';
        end generate U23d;    -- If (addrwidth <= 5) no write enable or output enable select logic needed
        U24 : if (addrwidth <= 4) generate
                out_en_16 <= '1';
                wrt_en_16 <= WE;
        end generate U24;
    -- Generate the RAM cell and tri-state
        U25 : for j in (width - 1) downto 0 generate
            attribute \.ram_offset\ of URAM16 : label is "SDT" & integer'image(width) & "D" & integer'image(num_cell_64*64 + num_cell_32*32) & "W" & integer'image(j) & "E" & integer'image(get_end_depth(num_cell_64*64 + num_cell_32*32 + 16, depth)) & "X" & integer'image(j+1);
            begin
            URAM16 : RAM16X1D 
                port map (D => in_reg_s(j), A0 => low_waddr_s(0), A1 => low_waddr_s(1), A2 => low_waddr_s(2),
                          A3 => low_waddr_s(3), DPRA0 => low_raddr_s(0), DPRA1 => low_raddr_s(1), DPRA2 => low_raddr_s(2),
						  DPRA3 => low_raddr_s(3), WE => wrt_en_16, WCLK => CLK, DPO => out_bus_16s(num_cell_16,j));
                out_reg_s(j) <= out_bus_16s(num_cell_16,j) when (out_en_16 = '1') else 'Z';
        end generate U25;
    end generate U22;    
  end generate U44;
end architecture no_rw_check;

--
-- Last implementation is default
--
architecture select_ram of RAM_R_W is
function get_end_depth(size : integer ; depth : integer) return integer is
variable min_size : integer := 0;
begin
  min_size := depth;
  if (size < depth) then
    min_size := size;
  end if;
  return min_size;
end get_end_depth;
constant num_cells : integer := ((depth - 1)/128);            -- # of RAM128X1D cells needed
type out_bus_type is array (num_cells downto 0, width-1 downto 0) of std_logic;
signal out_bus : out_bus_type;                               -- 2D array of dout (input to tri-states)
signal out_en : std_logic_vector(num_cells downto 0);        -- enables for tri-states
signal wrt_en : std_logic_vector(num_cells downto 0);        -- write enables for each row of RAM cells
signal in_reg : std_logic_vector(width-1 downto 0);          -- used to register DIN 
signal out_reg : std_logic_vector(width-1 downto 0);         -- used to register DOUT
signal rad_reg : std_logic_vector(addrwidth-1 downto 0);     -- used to register RADDR
signal wad_reg : std_logic_vector(addrwidth-1 downto 0);     -- used to register WADDR
signal low_raddr : std_logic_vector(6 downto 0);             -- raddr bits input to RAM cells (4 bits required)
signal low_waddr : std_logic_vector(6 downto 0);             -- waddr bits input to RAM cells (4 bits required)
attribute \.ram_offset\ : string;

begin

    -- If addrwidth < 7 assign '0' to unused bits
    U1  : if (addrwidth = 1) generate
        low_raddr <= "000000" & rad_reg(0);
        low_waddr <= "000000" & wad_reg(0);
    end generate U1;
    U2  : if (addrwidth = 2) generate
        low_raddr <= "00000" & rad_reg(1 downto 0);
        low_waddr <= "00000" & wad_reg(1 downto 0);
    end generate U2;
    U3  : if (addrwidth = 3) generate
        low_raddr <= "0000" & rad_reg(2 downto 0);
        low_waddr <= "0000" & wad_reg(2 downto 0);
    end generate U3;
    U3a  : if (addrwidth = 4) generate
        low_raddr <= "000" & rad_reg(3 downto 0);
        low_waddr <= "000" & wad_reg(3 downto 0);
    end generate U3a;
    U3b  : if (addrwidth = 5) generate
        low_raddr <= "00" & rad_reg(4 downto 0);
        low_waddr <= "00" & wad_reg(4 downto 0);
    end generate U3b;
    U3c  : if (addrwidth = 6) generate
        low_raddr <= "0" & rad_reg(5 downto 0);
        low_waddr <= "0" & wad_reg(5 downto 0);
    end generate U3c;
    U4  : if (addrwidth > 6) generate
        low_raddr <= rad_reg(6 downto 0);
        low_waddr <= wad_reg(6 downto 0);
    end generate U4;

    -- If (din_reg) register DIN using CLK
    U5  : if (din_reg) generate
        process (CLK, DIN) begin
            if (CLK = '1' and CLK'event) then
                in_reg <= DIN;
            end if;
        end process;
    end generate U5;
    U6  : if (not din_reg) generate
            in_reg <= DIN;
    end generate U6;

    -- If (dout_reg) register DOUT using OCLK
    U7  : if (dout_reg) generate
        process (OCLK, out_reg) begin
            if (OCLK = '1' and OCLK'event) then
                DOUT <= out_reg;
            end if;
        end process;
    end generate U7;
    U8  : if (not dout_reg) generate
            DOUT <= out_reg;
    end generate U8;

    -- If (raddr_reg) register RADDR using OCLK
    U9  : if (raddr_reg) generate
        process (OCLK, RADDR) begin
            if (OCLK = '1' and OCLK'event) then
                rad_reg <= RADDR(addrwidth-1 downto 0);
            end if;
        end process;
    end generate U9;
    U10 : if (not raddr_reg) generate
            rad_reg <= RADDR;
    end generate U10;
        
    -- If (waddr_reg) register WADDR using CLK
    U15  : if (waddr_reg) generate
        process (CLK, WADDR) begin
            if (CLK = '1' and CLK'event) then
                wad_reg <= WADDR(addrwidth-1 downto 0);
            end if;
        end process;
    end generate U15;
    U16 : if (not waddr_reg) generate
            wad_reg <= WADDR;
    end generate U16;

    -- Generate the RAM cells and select logic
    U11 : for i in num_cells downto 0 generate
        -- If (addrwidth > 7) need to create write enable and output enable select logic
        U12 : if (addrwidth > 7) generate
                out_en(i) <= '1' when (rad_reg(addrwidth-1 downto 7) = i) else '0';
                wrt_en(i) <= WE when (wad_reg(addrwidth-1 downto 7) = i) else '0';
        end generate U12;
        -- If (addrwidth <= 7) no write enable or output enable select logic needed
        U13 : if (addrwidth <= 7) generate
                out_en(i) <= '1';
                wrt_en(i) <= WE;
            end generate U13;
    -- Gnerate the RAM cells and tri-states
        U14 : for j in (width - 1) downto 0 generate
            attribute \.ram_offset\ of URAM : label is "SDT" & integer'image(width) & "D" & integer'image(i*128) & "W" & integer'image(j) & "E" & integer'image(get_end_depth((i+1)*128, depth)) & "X" & integer'image(j+1);
            begin
            URAM: RAM128X1D 
                port map (D => in_reg(j), A(0) => low_waddr(0), A(1) => low_waddr(1), A(2) => low_waddr(2),
                          A(3) => low_waddr(3), A(4) => low_waddr(4), A(5) => low_waddr(5), A(6) => low_waddr(6), 
			  DPRA(0) => low_raddr(0), DPRA(1) => low_raddr(1), 
                          DPRA(2) => low_raddr(2), DPRA(3) => low_raddr(3), 
                          DPRA(4) => low_raddr(4), DPRA(5) => low_raddr(5), DPRA(6) => low_raddr(6),
			  WE => wrt_en(i), 
                          WCLK => CLK, DPO => out_bus(i,j));
            out_reg(j) <= out_bus(i,j) when (out_en(i) = '1') else 'Z';
            end generate U14;
        end generate U11;
                             
end architecture select_ram;


